// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: admin.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// This message is handled by the Admin module and is responsible for all settings/channel read/write operations.
/// This message is used to do settings operations to both remote AND local nodes.
/// (Prior to 1.2 these operations were done via special ToRadio operations)
struct AdminMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// TODO: REPLACE
  var variant: AdminMessage.OneOf_Variant? = nil

  ///
  /// Set the owner for this node
  var setOwner: User {
    get {
      if case .setOwner(let v)? = variant {return v}
      return User()
    }
    set {variant = .setOwner(newValue)}
  }

  ///
  /// Set channels (using the new API).
  /// A special channel is the "primary channel".
  /// The other records are secondary channels.
  /// Note: only one channel can be marked as primary.
  /// If the client sets a particular channel to be primary, the previous channel will be set to SECONDARY automatically.
  var setChannel: Channel {
    get {
      if case .setChannel(let v)? = variant {return v}
      return Channel()
    }
    set {variant = .setChannel(newValue)}
  }

  ///
  /// Send the specified channel in the response to this message
  /// NOTE: This field is sent with the channel index + 1 (to ensure we never try to send 'zero' - which protobufs treats as not present)
  var getChannelRequest: UInt32 {
    get {
      if case .getChannelRequest(let v)? = variant {return v}
      return 0
    }
    set {variant = .getChannelRequest(newValue)}
  }

  ///
  /// TODO: REPLACE
  var getChannelResponse: Channel {
    get {
      if case .getChannelResponse(let v)? = variant {return v}
      return Channel()
    }
    set {variant = .getChannelResponse(newValue)}
  }

  ///
  /// Send the current owner data in the response to this message.
  var getOwnerRequest: Bool {
    get {
      if case .getOwnerRequest(let v)? = variant {return v}
      return false
    }
    set {variant = .getOwnerRequest(newValue)}
  }

  ///
  /// TODO: REPLACE
  var getOwnerResponse: User {
    get {
      if case .getOwnerResponse(let v)? = variant {return v}
      return User()
    }
    set {variant = .getOwnerResponse(newValue)}
  }

  ///
  /// Ask for the following config data to be sent
  var getConfigRequest: AdminMessage.ConfigType {
    get {
      if case .getConfigRequest(let v)? = variant {return v}
      return .deviceConfig
    }
    set {variant = .getConfigRequest(newValue)}
  }

  ///
  /// Send the current Config in the response to this message.
  var getConfigResponse: Config {
    get {
      if case .getConfigResponse(let v)? = variant {return v}
      return Config()
    }
    set {variant = .getConfigResponse(newValue)}
  }

  ///
  /// Set the current Config
  var setConfig: Config {
    get {
      if case .setConfig(let v)? = variant {return v}
      return Config()
    }
    set {variant = .setConfig(newValue)}
  }

  ///
  /// Sent immediatly after a config change has been sent to ensure comms, if this is not recieved, the config will be reverted after 10 mins
  var confirmSetConfig: Bool {
    get {
      if case .confirmSetConfig(let v)? = variant {return v}
      return false
    }
    set {variant = .confirmSetConfig(newValue)}
  }

  ///
  /// Ask for the following config data to be sent
  var getModuleConfigRequest: AdminMessage.ModuleConfigType {
    get {
      if case .getModuleConfigRequest(let v)? = variant {return v}
      return .mqttConfig
    }
    set {variant = .getModuleConfigRequest(newValue)}
  }

  ///
  /// Send the current Config in the response to this message.
  var getModuleConfigResponse: ModuleConfig {
    get {
      if case .getModuleConfigResponse(let v)? = variant {return v}
      return ModuleConfig()
    }
    set {variant = .getModuleConfigResponse(newValue)}
  }

  ///
  /// Set the current Config
  var setModuleConfig: ModuleConfig {
    get {
      if case .setModuleConfig(let v)? = variant {return v}
      return ModuleConfig()
    }
    set {variant = .setModuleConfig(newValue)}
  }

  ///
  /// Sent immediatly after a config change has been sent to ensure comms, if this is not recieved, the config will be reverted after 10 mins
  var confirmSetModuleConfig: Bool {
    get {
      if case .confirmSetModuleConfig(let v)? = variant {return v}
      return false
    }
    set {variant = .confirmSetModuleConfig(newValue)}
  }

  ///
  /// Send all channels in the response to this message
  var getAllChannelRequest: Bool {
    get {
      if case .getAllChannelRequest(let v)? = variant {return v}
      return false
    }
    set {variant = .getAllChannelRequest(newValue)}
  }

  ///
  /// Setting channels/radio config remotely carries the risk that you might send an invalid config and the radio never talks to your mesh again.
  /// Therefore if setting either of these properties remotely, you must send a confirm_xxx message within 10 minutes.
  /// If you fail to do so, the radio will assume loss of comms and revert your changes.
  /// These messages are optional when changing the local node.
  var confirmSetChannel: Bool {
    get {
      if case .confirmSetChannel(let v)? = variant {return v}
      return false
    }
    set {variant = .confirmSetChannel(newValue)}
  }

  ///
  /// TODO: REPLACE
  var confirmSetRadio: Bool {
    get {
      if case .confirmSetRadio(let v)? = variant {return v}
      return false
    }
    set {variant = .confirmSetRadio(newValue)}
  }

  ///
  /// This message is only supported for the simulator porduino build.
  /// If received the simulator will exit successfully.
  var exitSimulator: Bool {
    get {
      if case .exitSimulator(let v)? = variant {return v}
      return false
    }
    set {variant = .exitSimulator(newValue)}
  }

  ///
  /// Tell the node to reboot in this many seconds (or <0 to cancel reboot)
  var rebootSeconds: Int32 {
    get {
      if case .rebootSeconds(let v)? = variant {return v}
      return 0
    }
    set {variant = .rebootSeconds(newValue)}
  }

  ///
  /// Get the Canned Message Module message part1 in the response to this message.
  var getCannedMessageModulePart1Request: Bool {
    get {
      if case .getCannedMessageModulePart1Request(let v)? = variant {return v}
      return false
    }
    set {variant = .getCannedMessageModulePart1Request(newValue)}
  }

  ///
  /// TODO: REPLACE
  var getCannedMessageModulePart1Response: String {
    get {
      if case .getCannedMessageModulePart1Response(let v)? = variant {return v}
      return String()
    }
    set {variant = .getCannedMessageModulePart1Response(newValue)}
  }

  ///
  /// Get the Canned Message Module message part2 in the response to this message.
  var getCannedMessageModulePart2Request: Bool {
    get {
      if case .getCannedMessageModulePart2Request(let v)? = variant {return v}
      return false
    }
    set {variant = .getCannedMessageModulePart2Request(newValue)}
  }

  ///
  /// TODO: REPLACE
  var getCannedMessageModulePart2Response: String {
    get {
      if case .getCannedMessageModulePart2Response(let v)? = variant {return v}
      return String()
    }
    set {variant = .getCannedMessageModulePart2Response(newValue)}
  }

  ///
  /// Get the Canned Message Module message part3 in the response to this message.
  var getCannedMessageModulePart3Request: Bool {
    get {
      if case .getCannedMessageModulePart3Request(let v)? = variant {return v}
      return false
    }
    set {variant = .getCannedMessageModulePart3Request(newValue)}
  }

  ///
  /// TODO: REPLACE
  var getCannedMessageModulePart3Response: String {
    get {
      if case .getCannedMessageModulePart3Response(let v)? = variant {return v}
      return String()
    }
    set {variant = .getCannedMessageModulePart3Response(newValue)}
  }

  ///
  /// Get the Canned Message Module message part4 in the response to this message.
  var getCannedMessageModulePart4Request: Bool {
    get {
      if case .getCannedMessageModulePart4Request(let v)? = variant {return v}
      return false
    }
    set {variant = .getCannedMessageModulePart4Request(newValue)}
  }

  ///
  /// TODO: REPLACE
  var getCannedMessageModulePart4Response: String {
    get {
      if case .getCannedMessageModulePart4Response(let v)? = variant {return v}
      return String()
    }
    set {variant = .getCannedMessageModulePart4Response(newValue)}
  }

  ///
  /// Set the canned message module part 1 text.
  var setCannedMessageModulePart1: String {
    get {
      if case .setCannedMessageModulePart1(let v)? = variant {return v}
      return String()
    }
    set {variant = .setCannedMessageModulePart1(newValue)}
  }

  ///
  /// Set the canned message module part 2 text.
  var setCannedMessageModulePart2: String {
    get {
      if case .setCannedMessageModulePart2(let v)? = variant {return v}
      return String()
    }
    set {variant = .setCannedMessageModulePart2(newValue)}
  }

  ///
  /// Set the canned message module part 3 text.
  var setCannedMessageModulePart3: String {
    get {
      if case .setCannedMessageModulePart3(let v)? = variant {return v}
      return String()
    }
    set {variant = .setCannedMessageModulePart3(newValue)}
  }

  ///
  /// Set the canned message module part 4 text.
  var setCannedMessageModulePart4: String {
    get {
      if case .setCannedMessageModulePart4(let v)? = variant {return v}
      return String()
    }
    set {variant = .setCannedMessageModulePart4(newValue)}
  }

  ///
  /// Tell the node to shutdown in this many seconds (or <0 to cancel shutdown)
  var shutdownSeconds: Int32 {
    get {
      if case .shutdownSeconds(let v)? = variant {return v}
      return 0
    }
    set {variant = .shutdownSeconds(newValue)}
  }

  ///
  /// Request the node to send device metadata (firmware, protobuf version, etc)
  var getDeviceMetadataRequest: UInt32 {
    get {
      if case .getDeviceMetadataRequest(let v)? = variant {return v}
      return 0
    }
    set {variant = .getDeviceMetadataRequest(newValue)}
  }

  ///
  /// Device metadata response
  var getDeviceMetadataResponse: DeviceMetadata {
    get {
      if case .getDeviceMetadataResponse(let v)? = variant {return v}
      return DeviceMetadata()
    }
    set {variant = .getDeviceMetadataResponse(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// TODO: REPLACE
  enum OneOf_Variant: Equatable {
    ///
    /// Set the owner for this node
    case setOwner(User)
    ///
    /// Set channels (using the new API).
    /// A special channel is the "primary channel".
    /// The other records are secondary channels.
    /// Note: only one channel can be marked as primary.
    /// If the client sets a particular channel to be primary, the previous channel will be set to SECONDARY automatically.
    case setChannel(Channel)
    ///
    /// Send the specified channel in the response to this message
    /// NOTE: This field is sent with the channel index + 1 (to ensure we never try to send 'zero' - which protobufs treats as not present)
    case getChannelRequest(UInt32)
    ///
    /// TODO: REPLACE
    case getChannelResponse(Channel)
    ///
    /// Send the current owner data in the response to this message.
    case getOwnerRequest(Bool)
    ///
    /// TODO: REPLACE
    case getOwnerResponse(User)
    ///
    /// Ask for the following config data to be sent
    case getConfigRequest(AdminMessage.ConfigType)
    ///
    /// Send the current Config in the response to this message.
    case getConfigResponse(Config)
    ///
    /// Set the current Config
    case setConfig(Config)
    ///
    /// Sent immediatly after a config change has been sent to ensure comms, if this is not recieved, the config will be reverted after 10 mins
    case confirmSetConfig(Bool)
    ///
    /// Ask for the following config data to be sent
    case getModuleConfigRequest(AdminMessage.ModuleConfigType)
    ///
    /// Send the current Config in the response to this message.
    case getModuleConfigResponse(ModuleConfig)
    ///
    /// Set the current Config
    case setModuleConfig(ModuleConfig)
    ///
    /// Sent immediatly after a config change has been sent to ensure comms, if this is not recieved, the config will be reverted after 10 mins
    case confirmSetModuleConfig(Bool)
    ///
    /// Send all channels in the response to this message
    case getAllChannelRequest(Bool)
    ///
    /// Setting channels/radio config remotely carries the risk that you might send an invalid config and the radio never talks to your mesh again.
    /// Therefore if setting either of these properties remotely, you must send a confirm_xxx message within 10 minutes.
    /// If you fail to do so, the radio will assume loss of comms and revert your changes.
    /// These messages are optional when changing the local node.
    case confirmSetChannel(Bool)
    ///
    /// TODO: REPLACE
    case confirmSetRadio(Bool)
    ///
    /// This message is only supported for the simulator porduino build.
    /// If received the simulator will exit successfully.
    case exitSimulator(Bool)
    ///
    /// Tell the node to reboot in this many seconds (or <0 to cancel reboot)
    case rebootSeconds(Int32)
    ///
    /// Get the Canned Message Module message part1 in the response to this message.
    case getCannedMessageModulePart1Request(Bool)
    ///
    /// TODO: REPLACE
    case getCannedMessageModulePart1Response(String)
    ///
    /// Get the Canned Message Module message part2 in the response to this message.
    case getCannedMessageModulePart2Request(Bool)
    ///
    /// TODO: REPLACE
    case getCannedMessageModulePart2Response(String)
    ///
    /// Get the Canned Message Module message part3 in the response to this message.
    case getCannedMessageModulePart3Request(Bool)
    ///
    /// TODO: REPLACE
    case getCannedMessageModulePart3Response(String)
    ///
    /// Get the Canned Message Module message part4 in the response to this message.
    case getCannedMessageModulePart4Request(Bool)
    ///
    /// TODO: REPLACE
    case getCannedMessageModulePart4Response(String)
    ///
    /// Set the canned message module part 1 text.
    case setCannedMessageModulePart1(String)
    ///
    /// Set the canned message module part 2 text.
    case setCannedMessageModulePart2(String)
    ///
    /// Set the canned message module part 3 text.
    case setCannedMessageModulePart3(String)
    ///
    /// Set the canned message module part 4 text.
    case setCannedMessageModulePart4(String)
    ///
    /// Tell the node to shutdown in this many seconds (or <0 to cancel shutdown)
    case shutdownSeconds(Int32)
    ///
    /// Request the node to send device metadata (firmware, protobuf version, etc)
    case getDeviceMetadataRequest(UInt32)
    ///
    /// Device metadata response
    case getDeviceMetadataResponse(DeviceMetadata)

  #if !swift(>=4.1)
    static func ==(lhs: AdminMessage.OneOf_Variant, rhs: AdminMessage.OneOf_Variant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.setOwner, .setOwner): return {
        guard case .setOwner(let l) = lhs, case .setOwner(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setChannel, .setChannel): return {
        guard case .setChannel(let l) = lhs, case .setChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getChannelRequest, .getChannelRequest): return {
        guard case .getChannelRequest(let l) = lhs, case .getChannelRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getChannelResponse, .getChannelResponse): return {
        guard case .getChannelResponse(let l) = lhs, case .getChannelResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getOwnerRequest, .getOwnerRequest): return {
        guard case .getOwnerRequest(let l) = lhs, case .getOwnerRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getOwnerResponse, .getOwnerResponse): return {
        guard case .getOwnerResponse(let l) = lhs, case .getOwnerResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getConfigRequest, .getConfigRequest): return {
        guard case .getConfigRequest(let l) = lhs, case .getConfigRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getConfigResponse, .getConfigResponse): return {
        guard case .getConfigResponse(let l) = lhs, case .getConfigResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setConfig, .setConfig): return {
        guard case .setConfig(let l) = lhs, case .setConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.confirmSetConfig, .confirmSetConfig): return {
        guard case .confirmSetConfig(let l) = lhs, case .confirmSetConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getModuleConfigRequest, .getModuleConfigRequest): return {
        guard case .getModuleConfigRequest(let l) = lhs, case .getModuleConfigRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getModuleConfigResponse, .getModuleConfigResponse): return {
        guard case .getModuleConfigResponse(let l) = lhs, case .getModuleConfigResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setModuleConfig, .setModuleConfig): return {
        guard case .setModuleConfig(let l) = lhs, case .setModuleConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.confirmSetModuleConfig, .confirmSetModuleConfig): return {
        guard case .confirmSetModuleConfig(let l) = lhs, case .confirmSetModuleConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getAllChannelRequest, .getAllChannelRequest): return {
        guard case .getAllChannelRequest(let l) = lhs, case .getAllChannelRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.confirmSetChannel, .confirmSetChannel): return {
        guard case .confirmSetChannel(let l) = lhs, case .confirmSetChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.confirmSetRadio, .confirmSetRadio): return {
        guard case .confirmSetRadio(let l) = lhs, case .confirmSetRadio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exitSimulator, .exitSimulator): return {
        guard case .exitSimulator(let l) = lhs, case .exitSimulator(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rebootSeconds, .rebootSeconds): return {
        guard case .rebootSeconds(let l) = lhs, case .rebootSeconds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getCannedMessageModulePart1Request, .getCannedMessageModulePart1Request): return {
        guard case .getCannedMessageModulePart1Request(let l) = lhs, case .getCannedMessageModulePart1Request(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getCannedMessageModulePart1Response, .getCannedMessageModulePart1Response): return {
        guard case .getCannedMessageModulePart1Response(let l) = lhs, case .getCannedMessageModulePart1Response(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getCannedMessageModulePart2Request, .getCannedMessageModulePart2Request): return {
        guard case .getCannedMessageModulePart2Request(let l) = lhs, case .getCannedMessageModulePart2Request(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getCannedMessageModulePart2Response, .getCannedMessageModulePart2Response): return {
        guard case .getCannedMessageModulePart2Response(let l) = lhs, case .getCannedMessageModulePart2Response(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getCannedMessageModulePart3Request, .getCannedMessageModulePart3Request): return {
        guard case .getCannedMessageModulePart3Request(let l) = lhs, case .getCannedMessageModulePart3Request(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getCannedMessageModulePart3Response, .getCannedMessageModulePart3Response): return {
        guard case .getCannedMessageModulePart3Response(let l) = lhs, case .getCannedMessageModulePart3Response(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getCannedMessageModulePart4Request, .getCannedMessageModulePart4Request): return {
        guard case .getCannedMessageModulePart4Request(let l) = lhs, case .getCannedMessageModulePart4Request(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getCannedMessageModulePart4Response, .getCannedMessageModulePart4Response): return {
        guard case .getCannedMessageModulePart4Response(let l) = lhs, case .getCannedMessageModulePart4Response(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setCannedMessageModulePart1, .setCannedMessageModulePart1): return {
        guard case .setCannedMessageModulePart1(let l) = lhs, case .setCannedMessageModulePart1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setCannedMessageModulePart2, .setCannedMessageModulePart2): return {
        guard case .setCannedMessageModulePart2(let l) = lhs, case .setCannedMessageModulePart2(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setCannedMessageModulePart3, .setCannedMessageModulePart3): return {
        guard case .setCannedMessageModulePart3(let l) = lhs, case .setCannedMessageModulePart3(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setCannedMessageModulePart4, .setCannedMessageModulePart4): return {
        guard case .setCannedMessageModulePart4(let l) = lhs, case .setCannedMessageModulePart4(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.shutdownSeconds, .shutdownSeconds): return {
        guard case .shutdownSeconds(let l) = lhs, case .shutdownSeconds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getDeviceMetadataRequest, .getDeviceMetadataRequest): return {
        guard case .getDeviceMetadataRequest(let l) = lhs, case .getDeviceMetadataRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getDeviceMetadataResponse, .getDeviceMetadataResponse): return {
        guard case .getDeviceMetadataResponse(let l) = lhs, case .getDeviceMetadataResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  ///
  /// TODO: REPLACE
  enum ConfigType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// TODO: REPLACE
    case deviceConfig // = 0

    ///
    /// TODO: REPLACE
    case positionConfig // = 1

    ///
    /// TODO: REPLACE
    case powerConfig // = 2

    ///
    /// TODO: REPLACE
    case wifiConfig // = 3

    ///
    /// TODO: REPLACE
    case displayConfig // = 4

    ///
    /// TODO: REPLACE
    case loraConfig // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .deviceConfig
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .deviceConfig
      case 1: self = .positionConfig
      case 2: self = .powerConfig
      case 3: self = .wifiConfig
      case 4: self = .displayConfig
      case 5: self = .loraConfig
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .deviceConfig: return 0
      case .positionConfig: return 1
      case .powerConfig: return 2
      case .wifiConfig: return 3
      case .displayConfig: return 4
      case .loraConfig: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  ///
  /// TODO: REPLACE
  enum ModuleConfigType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// TODO: REPLACE
    case mqttConfig // = 0

    ///
    /// TODO: REPLACE
    case serialConfig // = 1

    ///
    /// TODO: REPLACE
    case extnotifConfig // = 2

    ///
    /// TODO: REPLACE
    case storeforwardConfig // = 3

    ///
    /// TODO: REPLACE
    case rangetestConfig // = 4

    ///
    /// TODO: REPLACE
    case telemetryConfig // = 5

    ///
    /// TODO: REPLACE
    case cannedmsgConfig // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .mqttConfig
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .mqttConfig
      case 1: self = .serialConfig
      case 2: self = .extnotifConfig
      case 3: self = .storeforwardConfig
      case 4: self = .rangetestConfig
      case 5: self = .telemetryConfig
      case 6: self = .cannedmsgConfig
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .mqttConfig: return 0
      case .serialConfig: return 1
      case .extnotifConfig: return 2
      case .storeforwardConfig: return 3
      case .rangetestConfig: return 4
      case .telemetryConfig: return 5
      case .cannedmsgConfig: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension AdminMessage.ConfigType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [AdminMessage.ConfigType] = [
    .deviceConfig,
    .positionConfig,
    .powerConfig,
    .wifiConfig,
    .displayConfig,
    .loraConfig,
  ]
}

extension AdminMessage.ModuleConfigType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [AdminMessage.ModuleConfigType] = [
    .mqttConfig,
    .serialConfig,
    .extnotifConfig,
    .storeforwardConfig,
    .rangetestConfig,
    .telemetryConfig,
    .cannedmsgConfig,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension AdminMessage: @unchecked Sendable {}
extension AdminMessage.OneOf_Variant: @unchecked Sendable {}
extension AdminMessage.ConfigType: @unchecked Sendable {}
extension AdminMessage.ModuleConfigType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension AdminMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AdminMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "set_owner"),
    3: .standard(proto: "set_channel"),
    6: .standard(proto: "get_channel_request"),
    7: .standard(proto: "get_channel_response"),
    8: .standard(proto: "get_owner_request"),
    9: .standard(proto: "get_owner_response"),
    10: .standard(proto: "get_config_request"),
    11: .standard(proto: "get_config_response"),
    12: .standard(proto: "set_config"),
    13: .standard(proto: "confirm_set_config"),
    14: .standard(proto: "get_module_config_request"),
    15: .standard(proto: "get_module_config_response"),
    16: .standard(proto: "set_module_config"),
    17: .standard(proto: "confirm_set_module_config"),
    18: .standard(proto: "get_all_channel_request"),
    32: .standard(proto: "confirm_set_channel"),
    33: .standard(proto: "confirm_set_radio"),
    34: .standard(proto: "exit_simulator"),
    35: .standard(proto: "reboot_seconds"),
    36: .standard(proto: "get_canned_message_module_part1_request"),
    37: .standard(proto: "get_canned_message_module_part1_response"),
    38: .standard(proto: "get_canned_message_module_part2_request"),
    39: .standard(proto: "get_canned_message_module_part2_response"),
    40: .standard(proto: "get_canned_message_module_part3_request"),
    41: .standard(proto: "get_canned_message_module_part3_response"),
    42: .standard(proto: "get_canned_message_module_part4_request"),
    43: .standard(proto: "get_canned_message_module_part4_response"),
    44: .standard(proto: "set_canned_message_module_part1"),
    45: .standard(proto: "set_canned_message_module_part2"),
    46: .standard(proto: "set_canned_message_module_part3"),
    47: .standard(proto: "set_canned_message_module_part4"),
    51: .standard(proto: "shutdown_seconds"),
    52: .standard(proto: "get_device_metadata_request"),
    53: .standard(proto: "get_device_metadata_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: User?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .setOwner(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .setOwner(v)
        }
      }()
      case 3: try {
        var v: Channel?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .setChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .setChannel(v)
        }
      }()
      case 6: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getChannelRequest(v)
        }
      }()
      case 7: try {
        var v: Channel?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .getChannelResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .getChannelResponse(v)
        }
      }()
      case 8: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getOwnerRequest(v)
        }
      }()
      case 9: try {
        var v: User?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .getOwnerResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .getOwnerResponse(v)
        }
      }()
      case 10: try {
        var v: AdminMessage.ConfigType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getConfigRequest(v)
        }
      }()
      case 11: try {
        var v: Config?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .getConfigResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .getConfigResponse(v)
        }
      }()
      case 12: try {
        var v: Config?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .setConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .setConfig(v)
        }
      }()
      case 13: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .confirmSetConfig(v)
        }
      }()
      case 14: try {
        var v: AdminMessage.ModuleConfigType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getModuleConfigRequest(v)
        }
      }()
      case 15: try {
        var v: ModuleConfig?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .getModuleConfigResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .getModuleConfigResponse(v)
        }
      }()
      case 16: try {
        var v: ModuleConfig?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .setModuleConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .setModuleConfig(v)
        }
      }()
      case 17: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .confirmSetModuleConfig(v)
        }
      }()
      case 18: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getAllChannelRequest(v)
        }
      }()
      case 32: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .confirmSetChannel(v)
        }
      }()
      case 33: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .confirmSetRadio(v)
        }
      }()
      case 34: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .exitSimulator(v)
        }
      }()
      case 35: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .rebootSeconds(v)
        }
      }()
      case 36: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getCannedMessageModulePart1Request(v)
        }
      }()
      case 37: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getCannedMessageModulePart1Response(v)
        }
      }()
      case 38: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getCannedMessageModulePart2Request(v)
        }
      }()
      case 39: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getCannedMessageModulePart2Response(v)
        }
      }()
      case 40: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getCannedMessageModulePart3Request(v)
        }
      }()
      case 41: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getCannedMessageModulePart3Response(v)
        }
      }()
      case 42: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getCannedMessageModulePart4Request(v)
        }
      }()
      case 43: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getCannedMessageModulePart4Response(v)
        }
      }()
      case 44: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .setCannedMessageModulePart1(v)
        }
      }()
      case 45: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .setCannedMessageModulePart2(v)
        }
      }()
      case 46: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .setCannedMessageModulePart3(v)
        }
      }()
      case 47: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .setCannedMessageModulePart4(v)
        }
      }()
      case 51: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .shutdownSeconds(v)
        }
      }()
      case 52: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .getDeviceMetadataRequest(v)
        }
      }()
      case 53: try {
        var v: DeviceMetadata?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .getDeviceMetadataResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .getDeviceMetadataResponse(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .setOwner?: try {
      guard case .setOwner(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .setChannel?: try {
      guard case .setChannel(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .getChannelRequest?: try {
      guard case .getChannelRequest(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }()
    case .getChannelResponse?: try {
      guard case .getChannelResponse(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .getOwnerRequest?: try {
      guard case .getOwnerRequest(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case .getOwnerResponse?: try {
      guard case .getOwnerResponse(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .getConfigRequest?: try {
      guard case .getConfigRequest(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
    }()
    case .getConfigResponse?: try {
      guard case .getConfigResponse(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .setConfig?: try {
      guard case .setConfig(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .confirmSetConfig?: try {
      guard case .confirmSetConfig(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    }()
    case .getModuleConfigRequest?: try {
      guard case .getModuleConfigRequest(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 14)
    }()
    case .getModuleConfigResponse?: try {
      guard case .getModuleConfigResponse(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .setModuleConfig?: try {
      guard case .setModuleConfig(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .confirmSetModuleConfig?: try {
      guard case .confirmSetModuleConfig(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
    }()
    case .getAllChannelRequest?: try {
      guard case .getAllChannelRequest(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
    }()
    case .confirmSetChannel?: try {
      guard case .confirmSetChannel(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 32)
    }()
    case .confirmSetRadio?: try {
      guard case .confirmSetRadio(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 33)
    }()
    case .exitSimulator?: try {
      guard case .exitSimulator(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 34)
    }()
    case .rebootSeconds?: try {
      guard case .rebootSeconds(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 35)
    }()
    case .getCannedMessageModulePart1Request?: try {
      guard case .getCannedMessageModulePart1Request(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 36)
    }()
    case .getCannedMessageModulePart1Response?: try {
      guard case .getCannedMessageModulePart1Response(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 37)
    }()
    case .getCannedMessageModulePart2Request?: try {
      guard case .getCannedMessageModulePart2Request(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 38)
    }()
    case .getCannedMessageModulePart2Response?: try {
      guard case .getCannedMessageModulePart2Response(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 39)
    }()
    case .getCannedMessageModulePart3Request?: try {
      guard case .getCannedMessageModulePart3Request(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 40)
    }()
    case .getCannedMessageModulePart3Response?: try {
      guard case .getCannedMessageModulePart3Response(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 41)
    }()
    case .getCannedMessageModulePart4Request?: try {
      guard case .getCannedMessageModulePart4Request(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 42)
    }()
    case .getCannedMessageModulePart4Response?: try {
      guard case .getCannedMessageModulePart4Response(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 43)
    }()
    case .setCannedMessageModulePart1?: try {
      guard case .setCannedMessageModulePart1(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 44)
    }()
    case .setCannedMessageModulePart2?: try {
      guard case .setCannedMessageModulePart2(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 45)
    }()
    case .setCannedMessageModulePart3?: try {
      guard case .setCannedMessageModulePart3(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 46)
    }()
    case .setCannedMessageModulePart4?: try {
      guard case .setCannedMessageModulePart4(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 47)
    }()
    case .shutdownSeconds?: try {
      guard case .shutdownSeconds(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 51)
    }()
    case .getDeviceMetadataRequest?: try {
      guard case .getDeviceMetadataRequest(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 52)
    }()
    case .getDeviceMetadataResponse?: try {
      guard case .getDeviceMetadataResponse(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AdminMessage, rhs: AdminMessage) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AdminMessage.ConfigType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_CONFIG"),
    1: .same(proto: "POSITION_CONFIG"),
    2: .same(proto: "POWER_CONFIG"),
    3: .same(proto: "WIFI_CONFIG"),
    4: .same(proto: "DISPLAY_CONFIG"),
    5: .same(proto: "LORA_CONFIG"),
  ]
}

extension AdminMessage.ModuleConfigType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MQTT_CONFIG"),
    1: .same(proto: "SERIAL_CONFIG"),
    2: .same(proto: "EXTNOTIF_CONFIG"),
    3: .same(proto: "STOREFORWARD_CONFIG"),
    4: .same(proto: "RANGETEST_CONFIG"),
    5: .same(proto: "TELEMETRY_CONFIG"),
    6: .same(proto: "CANNEDMSG_CONFIG"),
  ]
}
