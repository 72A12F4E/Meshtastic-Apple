// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: radioconfig.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// The frequency/regulatory region the user has selected.
/// Note: In 1.0 builds (which must still be supported by the android app for a
/// long time) this field will be unpopulated.
/// If firmware is ever upgraded from an old 1.0ish build, the old
/// MyNodeInfo.region string will be used to set UserPreferences.region and the
/// old value will be no longer set.
enum RegionCode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// TODO: REPLACE
  case unset // = 0

  ///
  /// TODO: REPLACE
  case us // = 1

  ///
  /// TODO: REPLACE
  case eu433 // = 2

  ///
  /// TODO: REPLACE
  case eu868 // = 3

  ///
  /// TODO: REPLACE
  case cn // = 4

  ///
  /// TODO: REPLACE
  case jp // = 5

  ///
  /// TODO: REPLACE
  case anz // = 6

  ///
  /// TODO: REPLACE
  case kr // = 7

  ///
  /// TODO: REPLACE
  case tw // = 8

  ///
  /// TODO: REPLACE
  case ru // = 9

  ///
  /// TODO: REPLACE
  case `in` // = 10

  ///
  /// TODO: REPLACE
  case nz865 // = 11

  ///
  /// TODO: REPLACE
  case th // = 12
  case UNRECOGNIZED(Int)

  init() {
    self = .unset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .us
    case 2: self = .eu433
    case 3: self = .eu868
    case 4: self = .cn
    case 5: self = .jp
    case 6: self = .anz
    case 7: self = .kr
    case 8: self = .tw
    case 9: self = .ru
    case 10: self = .in
    case 11: self = .nz865
    case 12: self = .th
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unset: return 0
    case .us: return 1
    case .eu433: return 2
    case .eu868: return 3
    case .cn: return 4
    case .jp: return 5
    case .anz: return 6
    case .kr: return 7
    case .tw: return 8
    case .ru: return 9
    case .in: return 10
    case .nz865: return 11
    case .th: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RegionCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RegionCode] = [
    .unset,
    .us,
    .eu433,
    .eu868,
    .cn,
    .jp,
    .anz,
    .kr,
    .tw,
    .ru,
    .in,
    .nz865,
    .th,
  ]
}

#endif  // swift(>=4.2)

///
/// Defines the device's role on the Mesh network
///   unset
///     Behave normally.
///   Router
///     Functions as a router
enum Role: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// Client device role
  case client // = 0

  ///
  /// ClientMute device role
  ///   This is like the client but packets will not hop over this node. Would be
  ///   useful if you want to save power by not contributing to the mesh.
  case clientMute // = 1

  ///
  /// Router device role.
  ///   Uses an agressive algirithem for the flood networking so packets will
  ///   prefer to be routed over this node. Also assume that this will be generally
  ///   unattended and so will turn off the wifi/ble radio as well as the oled screen.
  case router // = 2

  ///
  /// RouterClient device role
  ///   Uses an agressive algirithem for the flood networking so packets will
  ///   prefer to be routed over this node. Similiar power management as a regular
  ///   client, so the RouterClient can be used as both a Router and a Client. Useful
  ///   as a well placed base station that you could also use to send messages.
  case routerClient // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .client
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .client
    case 1: self = .clientMute
    case 2: self = .router
    case 3: self = .routerClient
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .client: return 0
    case .clientMute: return 1
    case .router: return 2
    case .routerClient: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Role: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Role] = [
    .client,
    .clientMute,
    .router,
    .routerClient,
  ]
}

#endif  // swift(>=4.2)

///
/// Sets the charge control current of devices with a battery charger that can be
/// configured. This is passed into the axp power management chip like on the tbeam.
enum ChargeCurrent: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// TODO: REPLACE
  case maunset // = 0

  ///
  /// TODO: REPLACE
  case ma100 // = 1

  ///
  /// TODO: REPLACE
  case ma190 // = 2

  ///
  /// TODO: REPLACE
  case ma280 // = 3

  ///
  /// TODO: REPLACE
  case ma360 // = 4

  ///
  /// TODO: REPLACE
  case ma450 // = 5

  ///
  /// TODO: REPLACE
  case ma550 // = 6

  ///
  /// TODO: REPLACE
  case ma630 // = 7

  ///
  /// TODO: REPLACE
  case ma700 // = 8

  ///
  /// TODO: REPLACE
  case ma780 // = 9

  ///
  /// TODO: REPLACE
  case ma880 // = 10

  ///
  /// TODO: REPLACE
  case ma960 // = 11

  ///
  /// TODO: REPLACE
  case ma1000 // = 12

  ///
  /// TODO: REPLACE
  case ma1080 // = 13

  ///
  /// TODO: REPLACE
  case ma1160 // = 14

  ///
  /// TODO: REPLACE
  case ma1240 // = 15

  ///
  /// TODO: REPLACE
  case ma1320 // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .maunset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .maunset
    case 1: self = .ma100
    case 2: self = .ma190
    case 3: self = .ma280
    case 4: self = .ma360
    case 5: self = .ma450
    case 6: self = .ma550
    case 7: self = .ma630
    case 8: self = .ma700
    case 9: self = .ma780
    case 10: self = .ma880
    case 11: self = .ma960
    case 12: self = .ma1000
    case 13: self = .ma1080
    case 14: self = .ma1160
    case 15: self = .ma1240
    case 16: self = .ma1320
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .maunset: return 0
    case .ma100: return 1
    case .ma190: return 2
    case .ma280: return 3
    case .ma360: return 4
    case .ma450: return 5
    case .ma550: return 6
    case .ma630: return 7
    case .ma700: return 8
    case .ma780: return 9
    case .ma880: return 10
    case .ma960: return 11
    case .ma1000: return 12
    case .ma1080: return 13
    case .ma1160: return 14
    case .ma1240: return 15
    case .ma1320: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ChargeCurrent: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ChargeCurrent] = [
    .maunset,
    .ma100,
    .ma190,
    .ma280,
    .ma360,
    .ma450,
    .ma550,
    .ma630,
    .ma700,
    .ma780,
    .ma880,
    .ma960,
    .ma1000,
    .ma1080,
    .ma1160,
    .ma1240,
    .ma1320,
  ]
}

#endif  // swift(>=4.2)

///
/// How the GPS coordinates are displayed on the OLED screen.
enum GpsCoordinateFormat: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// GPS coordinates are displayed in the normal decimal degrees format:
  /// DD.DDDDDD DDD.DDDDDD
  case gpsFormatDec // = 0

  ///
  /// GPS coordinates are displayed in the degrees minutes seconds format:
  /// DD°MM'SS"C DDD°MM'SS"C, where C is the compass point representing the locations quadrant
  case gpsFormatDms // = 1

  ///
  /// GPS coordinates are displayed in Universal Transverse Mercator format:
  /// ZZB EEEEEE NNNNNNN, where Z is zone, B is band, E is easting, N is northing
  case gpsFormatUtm // = 2

  ///
  /// GPS coordinates are displayed in Military Grid Reference System format:
  /// ZZB CD EEEEE NNNNN, where Z is zone, B is band, C is the east 100k square, D is the north 100k square,
  /// E is easting, N is northing
  case gpsFormatMgrs // = 3

  ///
  /// GPS coordinates are displayed in Open Location Code (aka Plus Codes).
  case gpsFormatOlc // = 4

  ///
  /// GPS coordinates are displayed in Ordnance Survey Grid Reference (the National Grid System of the UK).
  /// Format: AB EEEEE NNNNN, where A is the east 100k square, B is the north 100k square, E is the easting,
  /// N is the northing
  case gpsFormatOsgr // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .gpsFormatDec
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .gpsFormatDec
    case 1: self = .gpsFormatDms
    case 2: self = .gpsFormatUtm
    case 3: self = .gpsFormatMgrs
    case 4: self = .gpsFormatOlc
    case 5: self = .gpsFormatOsgr
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .gpsFormatDec: return 0
    case .gpsFormatDms: return 1
    case .gpsFormatUtm: return 2
    case .gpsFormatMgrs: return 3
    case .gpsFormatOlc: return 4
    case .gpsFormatOsgr: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension GpsCoordinateFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [GpsCoordinateFormat] = [
    .gpsFormatDec,
    .gpsFormatDms,
    .gpsFormatUtm,
    .gpsFormatMgrs,
    .gpsFormatOlc,
    .gpsFormatOsgr,
  ]
}

#endif  // swift(>=4.2)

///
/// Bit field of boolean configuration options, indicating which optional
///   fields to include when assembling POSITION messages
/// Longitude and latitude are always included (also time if GPS-synced)
/// NOTE: the more fields are included, the larger the message will be -
///   leading to longer airtime and a higher risk of packet loss
enum PositionFlags: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// Required for compilation
  case posUndefined // = 0

  ///
  /// Include an altitude value (if available)
  case posAltitude // = 1

  ///
  /// Altitude value is MSL
  case posAltMsl // = 2

  ///
  /// Include geoidal separation
  case posGeoSep // = 4

  ///
  /// Include the DOP value ; PDOP used by default, see below
  case posDop // = 8

  ///
  /// If POS_DOP set, send separate HDOP / VDOP values instead of PDOP
  case posHvdop // = 16

  ///
  /// Include battery level
  case posBattery // = 32

  ///
  /// Include number of "satellites in view"
  case posSatinview // = 64

  ///
  /// Include a sequence number incremented per packet
  case posSeqNos // = 128

  ///
  /// Include positional timestamp (from GPS solution)
  case posTimestamp // = 256
  case UNRECOGNIZED(Int)

  init() {
    self = .posUndefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .posUndefined
    case 1: self = .posAltitude
    case 2: self = .posAltMsl
    case 4: self = .posGeoSep
    case 8: self = .posDop
    case 16: self = .posHvdop
    case 32: self = .posBattery
    case 64: self = .posSatinview
    case 128: self = .posSeqNos
    case 256: self = .posTimestamp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .posUndefined: return 0
    case .posAltitude: return 1
    case .posAltMsl: return 2
    case .posGeoSep: return 4
    case .posDop: return 8
    case .posHvdop: return 16
    case .posBattery: return 32
    case .posSatinview: return 64
    case .posSeqNos: return 128
    case .posTimestamp: return 256
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PositionFlags: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PositionFlags] = [
    .posUndefined,
    .posAltitude,
    .posAltMsl,
    .posGeoSep,
    .posDop,
    .posHvdop,
    .posBattery,
    .posSatinview,
    .posSeqNos,
    .posTimestamp,
  ]
}

#endif  // swift(>=4.2)

///
/// TODO: REPLACE
enum InputEventChar: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  /// TODO: REPLACE
  case keyNone // = 0

  ///
  /// TODO: REPLACE
  case keyUp // = 17

  ///
  /// TODO: REPLACE
  case keyDown // = 18

  ///
  /// TODO: REPLACE
  case keyLeft // = 19

  ///
  /// TODO: REPLACE
  case keyRight // = 20

  ///
  /// '\n'
  case keySelect // = 10

  ///
  /// TODO: REPLACE
  case keyBack // = 27

  ///
  /// TODO: REPLACE
  case keyCancel // = 24
  case UNRECOGNIZED(Int)

  init() {
    self = .keyNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .keyNone
    case 10: self = .keySelect
    case 17: self = .keyUp
    case 18: self = .keyDown
    case 19: self = .keyLeft
    case 20: self = .keyRight
    case 24: self = .keyCancel
    case 27: self = .keyBack
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .keyNone: return 0
    case .keySelect: return 10
    case .keyUp: return 17
    case .keyDown: return 18
    case .keyLeft: return 19
    case .keyRight: return 20
    case .keyCancel: return 24
    case .keyBack: return 27
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension InputEventChar: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [InputEventChar] = [
    .keyNone,
    .keyUp,
    .keyDown,
    .keyLeft,
    .keyRight,
    .keySelect,
    .keyBack,
    .keyCancel,
  ]
}

#endif  // swift(>=4.2)

///
/// The entire set of user settable/readable settings for our radio device.
/// Includes both the current channel settings and any preferences the user has
/// set for behavior of their node
struct RadioConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// TODO: REPLACE
  var preferences: RadioConfig.UserPreferences {
    get {return _preferences ?? RadioConfig.UserPreferences()}
    set {_preferences = newValue}
  }
  /// Returns true if `preferences` has been explicitly set.
  var hasPreferences: Bool {return self._preferences != nil}
  /// Clears the value of `preferences`. Subsequent reads from it will return its default value.
  mutating func clearPreferences() {self._preferences = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// See [software design](/docs/software/other/sw-design) for more information on these preferences
  struct UserPreferences {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// We should send our position this often (but only if it has changed significantly)
    /// Defaults to 15 minutes
    var positionBroadcastSecs: UInt32 {
      get {return _storage._positionBroadcastSecs}
      set {_uniqueStorage()._positionBroadcastSecs = newValue}
    }

    ///
    /// We should send our position this often (but only if it has changed significantly)
    var positionBroadcastSmartDisabled: Bool {
      get {return _storage._positionBroadcastSmartDisabled}
      set {_uniqueStorage()._positionBroadcastSmartDisabled = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/docs/software/other/power) for details.
    /// 0 for default of 1 minute
    var waitBluetoothSecs: UInt32 {
      get {return _storage._waitBluetoothSecs}
      set {_uniqueStorage()._waitBluetoothSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/docs/software/other/power) for details.
    /// 0 for default of one minute
    var screenOnSecs: UInt32 {
      get {return _storage._screenOnSecs}
      set {_uniqueStorage()._screenOnSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/docs/software/other/power) for details.
    /// 0 for default of 15 minutes
    /// IMPORTANT NOTE FOR DEVICE CLIENTS: YOU MUST SEND SOME SORT OF PACKET TO THE PHONE AT LEAST THIS OFTEN OR THE DEVICE WILL DECIDE YOU ARE GONE!
    var phoneTimeoutSecs: UInt32 {
      get {return _storage._phoneTimeoutSecs}
      set {_uniqueStorage()._phoneTimeoutSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/docs/software/other/power) for details.
    /// 0 for default of two hours, MAXUINT for disabled
    var phoneSdsTimeoutSec: UInt32 {
      get {return _storage._phoneSdsTimeoutSec}
      set {_uniqueStorage()._phoneSdsTimeoutSec = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/docs/software/other/power) for details.
    /// 0 for default of two hours, MAXUINT for disabled
    var meshSdsTimeoutSecs: UInt32 {
      get {return _storage._meshSdsTimeoutSecs}
      set {_uniqueStorage()._meshSdsTimeoutSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/docs/software/other/power) for details.
    /// 0 for default of one year
    var sdsSecs: UInt32 {
      get {return _storage._sdsSecs}
      set {_uniqueStorage()._sdsSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/docs/software/other/power) for details.
    /// 0 for default of 3600
    var lsSecs: UInt32 {
      get {return _storage._lsSecs}
      set {_uniqueStorage()._lsSecs = newValue}
    }

    ///
    /// Power management state machine option.
    /// See [power management](/docs/software/other/power) for details.
    /// 0 for default of 10 seconds
    var minWakeSecs: UInt32 {
      get {return _storage._minWakeSecs}
      set {_uniqueStorage()._minWakeSecs = newValue}
    }

    ///
    /// If set, this node will try to join the specified wifi network and
    /// acquire an address via DHCP
    var wifiSsid: String {
      get {return _storage._wifiSsid}
      set {_uniqueStorage()._wifiSsid = newValue}
    }

    ///
    /// If set, will be use to authenticate to the named wifi
    var wifiPassword: String {
      get {return _storage._wifiPassword}
      set {_uniqueStorage()._wifiPassword = newValue}
    }

    ///
    /// If set, the node will operate as an AP (and DHCP server), otherwise it
    /// will be a station
    var wifiApMode: Bool {
      get {return _storage._wifiApMode}
      set {_uniqueStorage()._wifiApMode = newValue}
    }

    ///
    /// The region code for my radio (US, CN, EU433, etc...)
    var region: RegionCode {
      get {return _storage._region}
      set {_uniqueStorage()._region = newValue}
    }

    ///
    /// Sets the current of the battery charger
    var chargeCurrent: ChargeCurrent {
      get {return _storage._chargeCurrent}
      set {_uniqueStorage()._chargeCurrent = newValue}
    }

    ///
    /// Sets the role of node
    var role: Role {
      get {return _storage._role}
      set {_uniqueStorage()._role = newValue}
    }

    ///
    /// If set, we are powered from a low-current source (i.e. solar), so even if it looks like we have power flowing in
    /// we should try to minimize power consumption as much as possible.
    /// YOU DO NOT NEED TO SET THIS IF YOU'VE set is_router (it is implied in that case).
    var isLowPower: Bool {
      get {return _storage._isLowPower}
      set {_uniqueStorage()._isLowPower = newValue}
    }

    ///
    /// If set, this node is at a fixed position.
    /// We will generate GPS position updates at the regular interval, but use whatever the last lat/lon/alt we have for the node.
    /// The lat/lon/alt can be set by an internal GPS or with the help of the app.
    var fixedPosition: Bool {
      get {return _storage._fixedPosition}
      set {_uniqueStorage()._fixedPosition = newValue}
    }

    ///
    /// If set, this will disable the SerialConsole by not initilizing the StreamAPI
    var serialDisabled: Bool {
      get {return _storage._serialDisabled}
      set {_uniqueStorage()._serialDisabled = newValue}
    }

    ///
    /// Should we disbale location sharing with other nodes (or the local phone)
    var locationShareDisabled: Bool {
      get {return _storage._locationShareDisabled}
      set {_uniqueStorage()._locationShareDisabled = newValue}
    }

    ///
    /// Should the GPS be disabled for this node?
    var gpsDisabled: Bool {
      get {return _storage._gpsDisabled}
      set {_uniqueStorage()._gpsDisabled = newValue}
    }

    ///
    /// How often should we try to get GPS position (in seconds)
    /// or zero for the default of once every 30 seconds
    /// or a very large value (maxint) to update only once at boot.
    var gpsUpdateInterval: UInt32 {
      get {return _storage._gpsUpdateInterval}
      set {_uniqueStorage()._gpsUpdateInterval = newValue}
    }

    ///
    /// How long should we try to get our position during each gps_update_interval attempt?  (in seconds)
    /// Or if zero, use the default of 30 seconds.
    /// If we don't get a new gps fix in that time, the gps will be put into sleep until  the next gps_update_rate
    /// window.
    var gpsAttemptTime: UInt32 {
      get {return _storage._gpsAttemptTime}
      set {_uniqueStorage()._gpsAttemptTime = newValue}
    }

    ///
    /// Shall we accept 2D GPS fixes? By default, only 3D fixes are accepted
    /// (during a 2D fix, altitude values are unreliable and will be excluded)
    var gpsAccept2D: Bool {
      get {return _storage._gpsAccept2D}
      set {_uniqueStorage()._gpsAccept2D = newValue}
    }

    ///
    /// GPS maximum DOP accepted (dilution of precision)
    /// Set a rejection threshold for GPS readings based on their precision,
    /// relative to the GPS rated accuracy (which is typically ~3m)
    /// Solutions above this value will be treated as retryable errors!
    /// Useful range is between 1 - 64 (3m - <~200m)
    /// By default (if zero), accept all GPS readings
    var gpsMaxDop: UInt32 {
      get {return _storage._gpsMaxDop}
      set {_uniqueStorage()._gpsMaxDop = newValue}
    }

    ///
    /// This parameter is for advanced users with advanced test equipment, we do not recommend most users use it.
    /// A frequency offset that is added to to the calculated band center frequency.
    /// Used to correct for crystal calibration errors.
    var frequencyOffset: Float {
      get {return _storage._frequencyOffset}
      set {_uniqueStorage()._frequencyOffset = newValue}
    }

    ///
    /// The server to use for our MQTT global message gateway feature.
    /// If not set, the default server will be used
    var mqttServer: String {
      get {return _storage._mqttServer}
      set {_uniqueStorage()._mqttServer = newValue}
    }

    ///
    /// If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
    /// is_uplink_enabled or is_downlink_enabled.
    /// But if this flag is set, all MQTT features will be disabled and no servers will be contacted.
    var mqttDisabled: Bool {
      get {return _storage._mqttDisabled}
      set {_uniqueStorage()._mqttDisabled = newValue}
    }

    ///
    /// How the GPS coordinates are displayed on the OLED screen.
    var gpsFormat: GpsCoordinateFormat {
      get {return _storage._gpsFormat}
      set {_uniqueStorage()._gpsFormat = newValue}
    }

    ///
    /// This setting is never saved to disk, but if set, all device settings will be returned to factory defaults.
    /// (Region, serial number etc... will be preserved)
    var factoryReset: Bool {
      get {return _storage._factoryReset}
      set {_uniqueStorage()._factoryReset = newValue}
    }

    ///
    /// By default we turn off logging as soon as an API client connects (to keep shared serial link quiet).
    /// Set this to true to leave the debug log outputting even when API is active.
    var debugLogEnabled: Bool {
      get {return _storage._debugLogEnabled}
      set {_uniqueStorage()._debugLogEnabled = newValue}
    }

    ///
    /// If true, radio should not try to be smart about what packets to queue to
    /// the phone
    /// bool keep_all_packets = 101;
    /// If true, we will try to capture all the packets sent on the mesh, not just the ones destined to our node.
    /// bool promiscuous_mode = 102;
    /// For testing it is useful sometimes to force a node to never listen to
    /// particular other nodes (simulating radio out of range). All nodenums listed
    /// in ignore_incoming will have packets they send droped on receive (by router.cpp)
    var ignoreIncoming: [UInt32] {
      get {return _storage._ignoreIncoming}
      set {_uniqueStorage()._ignoreIncoming = newValue}
    }

    ///
    /// Preferences for the SerialModule
    /// FIXME - Move this out of UserPreferences and into a section for module configuration.
    var serialModuleEnabled: Bool {
      get {return _storage._serialModuleEnabled}
      set {_uniqueStorage()._serialModuleEnabled = newValue}
    }

    ///
    /// TODO: REPLACE
    var serialModuleEcho: Bool {
      get {return _storage._serialModuleEcho}
      set {_uniqueStorage()._serialModuleEcho = newValue}
    }

    ///
    /// TODO: REPLACE
    var serialModuleRxd: UInt32 {
      get {return _storage._serialModuleRxd}
      set {_uniqueStorage()._serialModuleRxd = newValue}
    }

    ///
    /// TODO: REPLACE
    var serialModuleTxd: UInt32 {
      get {return _storage._serialModuleTxd}
      set {_uniqueStorage()._serialModuleTxd = newValue}
    }

    ///
    /// TODO: REPLACE
    var serialModuleBaud: RadioConfig.UserPreferences.Serial_Baud {
      get {return _storage._serialModuleBaud}
      set {_uniqueStorage()._serialModuleBaud = newValue}
    }

    ///
    /// TODO: REPLACE
    var serialModuleTimeout: UInt32 {
      get {return _storage._serialModuleTimeout}
      set {_uniqueStorage()._serialModuleTimeout = newValue}
    }

    ///
    /// TODO: REPLACE
    var serialModuleMode: RadioConfig.UserPreferences.Serial_Mode {
      get {return _storage._serialModuleMode}
      set {_uniqueStorage()._serialModuleMode = newValue}
    }

    ///
    /// Preferences for the ExternalNotificationModule
    /// FIXME - Move this out of UserPreferences and into a section for module configuration.
    var extNotificationModuleEnabled: Bool {
      get {return _storage._extNotificationModuleEnabled}
      set {_uniqueStorage()._extNotificationModuleEnabled = newValue}
    }

    ///
    /// TODO: REPLACE
    var extNotificationModuleOutputMs: UInt32 {
      get {return _storage._extNotificationModuleOutputMs}
      set {_uniqueStorage()._extNotificationModuleOutputMs = newValue}
    }

    ///
    /// TODO: REPLACE
    var extNotificationModuleOutput: UInt32 {
      get {return _storage._extNotificationModuleOutput}
      set {_uniqueStorage()._extNotificationModuleOutput = newValue}
    }

    ///
    /// TODO: REPLACE
    var extNotificationModuleActive: Bool {
      get {return _storage._extNotificationModuleActive}
      set {_uniqueStorage()._extNotificationModuleActive = newValue}
    }

    ///
    /// TODO: REPLACE
    var extNotificationModuleAlertMessage: Bool {
      get {return _storage._extNotificationModuleAlertMessage}
      set {_uniqueStorage()._extNotificationModuleAlertMessage = newValue}
    }

    ///
    /// TODO: REPLACE
    var extNotificationModuleAlertBell: Bool {
      get {return _storage._extNotificationModuleAlertBell}
      set {_uniqueStorage()._extNotificationModuleAlertBell = newValue}
    }

    ///
    /// Preferences for the RangeTestModule
    /// FIXME - Move this out of UserPreferences and into a section for module configuration.
    var rangeTestModuleEnabled: Bool {
      get {return _storage._rangeTestModuleEnabled}
      set {_uniqueStorage()._rangeTestModuleEnabled = newValue}
    }

    ///
    /// TODO: REPLACE
    var rangeTestModuleSender: UInt32 {
      get {return _storage._rangeTestModuleSender}
      set {_uniqueStorage()._rangeTestModuleSender = newValue}
    }

    ///
    /// TODO: REPLACE
    var rangeTestModuleSave: Bool {
      get {return _storage._rangeTestModuleSave}
      set {_uniqueStorage()._rangeTestModuleSave = newValue}
    }

    ///
    /// Preferences for the StoreForwardModule
    ///FIXME - Move this out of UserPreferences and into a section for module configuration. (was 136)
    var storeForwardModuleEnabled: Bool {
      get {return _storage._storeForwardModuleEnabled}
      set {_uniqueStorage()._storeForwardModuleEnabled = newValue}
    }

    ///
    /// TODO: REPLACE
    var storeForwardModuleHeartbeat: Bool {
      get {return _storage._storeForwardModuleHeartbeat}
      set {_uniqueStorage()._storeForwardModuleHeartbeat = newValue}
    }

    ///
    /// TODO: REPLACE
    var storeForwardModuleRecords: UInt32 {
      get {return _storage._storeForwardModuleRecords}
      set {_uniqueStorage()._storeForwardModuleRecords = newValue}
    }

    ///
    /// TODO: REPLACE
    var storeForwardModuleHistoryReturnMax: UInt32 {
      get {return _storage._storeForwardModuleHistoryReturnMax}
      set {_uniqueStorage()._storeForwardModuleHistoryReturnMax = newValue}
    }

    ///
    /// TODO: REPLACE
    var storeForwardModuleHistoryReturnWindow: UInt32 {
      get {return _storage._storeForwardModuleHistoryReturnWindow}
      set {_uniqueStorage()._storeForwardModuleHistoryReturnWindow = newValue}
    }

    ///
    /// Preferences for the Telemetry Module (Environment)
    /// FIXME - Move this out of UserPreferences and into a section for module configuration.
    /// Enable/Disable the telemetry measurement module measurement collection
    var telemetryModuleEnvironmentMeasurementEnabled: Bool {
      get {return _storage._telemetryModuleEnvironmentMeasurementEnabled}
      set {_uniqueStorage()._telemetryModuleEnvironmentMeasurementEnabled = newValue}
    }

    ///
    /// Enable/Disable the telemetry measurement module on-device display
    var telemetryModuleEnvironmentScreenEnabled: Bool {
      get {return _storage._telemetryModuleEnvironmentScreenEnabled}
      set {_uniqueStorage()._telemetryModuleEnvironmentScreenEnabled = newValue}
    }

    ///
    /// Sometimes sensor reads can fail.
    /// If this happens, we will retry a configurable number of attempts,
    /// each attempt will be delayed by the minimum required refresh rate for that sensor
    var telemetryModuleEnvironmentReadErrorCountThreshold: UInt32 {
      get {return _storage._telemetryModuleEnvironmentReadErrorCountThreshold}
      set {_uniqueStorage()._telemetryModuleEnvironmentReadErrorCountThreshold = newValue}
    }

    ///
    /// Interval in seconds of how often we should try to send our
    /// measurements to the mesh
    var telemetryModuleDeviceUpdateInterval: UInt32 {
      get {return _storage._telemetryModuleDeviceUpdateInterval}
      set {_uniqueStorage()._telemetryModuleDeviceUpdateInterval = newValue}
    }

    ///
    /// Sometimes we can end up with more than read_error_count_threshold failures.
    /// In this case, we will stop trying to read from the sensor for a while.
    /// Wait this long until trying to read from the sensor again
    var telemetryModuleEnvironmentRecoveryInterval: UInt32 {
      get {return _storage._telemetryModuleEnvironmentRecoveryInterval}
      set {_uniqueStorage()._telemetryModuleEnvironmentRecoveryInterval = newValue}
    }

    ///
    /// We'll always read the sensor in Celsius, but sometimes we might want to
    /// display the results in Fahrenheit as a "user preference".
    var telemetryModuleEnvironmentDisplayFahrenheit: Bool {
      get {return _storage._telemetryModuleEnvironmentDisplayFahrenheit}
      set {_uniqueStorage()._telemetryModuleEnvironmentDisplayFahrenheit = newValue}
    }

    ///
    /// Specify the sensor type
    var telemetryModuleEnvironmentSensorType: RadioConfig.UserPreferences.TelemetrySensorType {
      get {return _storage._telemetryModuleEnvironmentSensorType}
      set {_uniqueStorage()._telemetryModuleEnvironmentSensorType = newValue}
    }

    ///
    /// Specify the peferred GPIO Pin for sensor readings
    var telemetryModuleEnvironmentSensorPin: UInt32 {
      get {return _storage._telemetryModuleEnvironmentSensorPin}
      set {_uniqueStorage()._telemetryModuleEnvironmentSensorPin = newValue}
    }

    ///
    /// Bit field of boolean configuration options for POSITION messages
    /// (bitwise OR of PositionFlags)
    var positionFlags: UInt32 {
      get {return _storage._positionFlags}
      set {_uniqueStorage()._positionFlags = newValue}
    }

    ///
    /// Circumvents the logic block for determining whether the device is powered or not.
    /// Useful for devices with finicky ADC issues on the battery sense pins.
    var isAlwaysPowered: Bool {
      get {return _storage._isAlwaysPowered}
      set {_uniqueStorage()._isAlwaysPowered = newValue}
    }

    ///
    /// Automatically toggles to the next page on the screen like a carousel, based the specified interval in seconds.
    /// Potentially useful for devices without user buttons.
    var autoScreenCarouselSecs: UInt32 {
      get {return _storage._autoScreenCarouselSecs}
      set {_uniqueStorage()._autoScreenCarouselSecs = newValue}
    }

    ///
    /// If non-zero, the device will fully power off this many seconds after external power is removed.
    var onBatteryShutdownAfterSecs: UInt32 {
      get {return _storage._onBatteryShutdownAfterSecs}
      set {_uniqueStorage()._onBatteryShutdownAfterSecs = newValue}
    }

    ///
    /// Overrides HOPS_RELIABLE and sets the maximum number of hops. This can't be greater than 7.
    var hopLimit: UInt32 {
      get {return _storage._hopLimit}
      set {_uniqueStorage()._hopLimit = newValue}
    }

    ///
    /// MQTT username to use (most useful for a custom MQTT server).
    /// If using a custom server, this will be honoured even if empty.
    /// If using the default server, this will only be honoured if set, otherwise the device will use the default username
    var mqttUsername: String {
      get {return _storage._mqttUsername}
      set {_uniqueStorage()._mqttUsername = newValue}
    }

    ///
    /// MQTT password to use (most useful for a custom MQTT server).
    /// If using a custom server, this will be honoured even if empty.
    /// If using the default server, this will only be honoured if set, otherwise the device will use the default password
    var mqttPassword: String {
      get {return _storage._mqttPassword}
      set {_uniqueStorage()._mqttPassword = newValue}
    }

    ///
    /// Disable TX from the LoRa radio. Useful for hot-swapping antennas and other tests.
    /// Defaults to false
    var isLoraTxDisabled: Bool {
      get {return _storage._isLoraTxDisabled}
      set {_uniqueStorage()._isLoraTxDisabled = newValue}
    }

    ///
    /// If set to true, enable power saving features of the esp32
    var isPowerSaving: Bool {
      get {return _storage._isPowerSaving}
      set {_uniqueStorage()._isPowerSaving = newValue}
    }

    ///
    /// Enable the rotary encoder #1. This is a 'dumb' encoder sending pulses on both A and B pins while rotating.
    var rotary1Enabled: Bool {
      get {return _storage._rotary1Enabled}
      set {_uniqueStorage()._rotary1Enabled = newValue}
    }

    ///
    /// GPIO pin for rotary encoder A port.
    var inputbrokerPinA: UInt32 {
      get {return _storage._inputbrokerPinA}
      set {_uniqueStorage()._inputbrokerPinA = newValue}
    }

    ///
    /// GPIO pin for rotary encoder B port.
    var inputbrokerPinB: UInt32 {
      get {return _storage._inputbrokerPinB}
      set {_uniqueStorage()._inputbrokerPinB = newValue}
    }

    ///
    /// GPIO pin for rotary encoder Press port.
    var inputbrokerPinPress: UInt32 {
      get {return _storage._inputbrokerPinPress}
      set {_uniqueStorage()._inputbrokerPinPress = newValue}
    }

    ///
    /// Generate input event on CW of this kind.
    var inputbrokerEventCw: InputEventChar {
      get {return _storage._inputbrokerEventCw}
      set {_uniqueStorage()._inputbrokerEventCw = newValue}
    }

    ///
    /// Generate input event on CCW of this kind.
    var inputbrokerEventCcw: InputEventChar {
      get {return _storage._inputbrokerEventCcw}
      set {_uniqueStorage()._inputbrokerEventCcw = newValue}
    }

    ///
    /// Generate input event on Press of this kind.
    var inputbrokerEventPress: InputEventChar {
      get {return _storage._inputbrokerEventPress}
      set {_uniqueStorage()._inputbrokerEventPress = newValue}
    }

    ///
    /// Enable the Up/Down/Select input device. Can be RAK rotary encoder or 3 buttons. Uses the a/b/press definitions from inputbroker.
    var updown1Enabled: Bool {
      get {return _storage._updown1Enabled}
      set {_uniqueStorage()._updown1Enabled = newValue}
    }

    ///
    /// Enable/disable CannedMessageModule.
    var cannedMessageModuleEnabled: Bool {
      get {return _storage._cannedMessageModuleEnabled}
      set {_uniqueStorage()._cannedMessageModuleEnabled = newValue}
    }

    ///
    /// Input event origin accepted by the canned message module.
    /// Can be e.g. "rotEnc1", "upDownEnc1" or keyword "_any"
    var cannedMessageModuleAllowInputSource: String {
      get {return _storage._cannedMessageModuleAllowInputSource}
      set {_uniqueStorage()._cannedMessageModuleAllowInputSource = newValue}
    }

    ///
    /// CannedMessageModule also sends a bell character with the messages.
    /// ExternalNotificationModule can benefit from this feature.
    var cannedMessageModuleSendBell: Bool {
      get {return _storage._cannedMessageModuleSendBell}
      set {_uniqueStorage()._cannedMessageModuleSendBell = newValue}
    }

    ///
    /// Whether to send encrypted or decrypted packets to MQTT.
    /// This parameter is only honoured if you also set mqtt_server
    /// (the default official mqtt.meshtastic.org server can handle encrypted packets)
    /// Decrypted packets may be useful for external systems that want to consume meshtastic packets
    var mqttEncryptionEnabled: Bool {
      get {return _storage._mqttEncryptionEnabled}
      set {_uniqueStorage()._mqttEncryptionEnabled = newValue}
    }

    ///
    /// Ratio of voltage divider for battery pin eg. 3.20 (R1=100k, R2=220k)
    /// Overrides the ADC_MULTIPLIER defined in variant for battery voltage calculation.
    var adcMultiplierOverride: Float {
      get {return _storage._adcMultiplierOverride}
      set {_uniqueStorage()._adcMultiplierOverride = newValue}
    }

    ///
    /// Interval in seconds of how often we should try to send our
    /// environent measurements to the mesh
    var telemetryModuleEnvironmentUpdateInterval: UInt32 {
      get {return _storage._telemetryModuleEnvironmentUpdateInterval}
      set {_uniqueStorage()._telemetryModuleEnvironmentUpdateInterval = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// TODO: REPLACE
    enum Serial_Baud: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case baudDefault // = 0
      case baud2400 // = 1
      case baud4800 // = 2
      case baud9600 // = 3
      case baud19200 // = 4
      case baud38400 // = 5
      case baud57600 // = 6
      case baud115200 // = 7
      case baud230400 // = 8
      case baud460800 // = 9
      case baud576000 // = 10
      case baud921600 // = 11
      case UNRECOGNIZED(Int)

      init() {
        self = .baudDefault
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .baudDefault
        case 1: self = .baud2400
        case 2: self = .baud4800
        case 3: self = .baud9600
        case 4: self = .baud19200
        case 5: self = .baud38400
        case 6: self = .baud57600
        case 7: self = .baud115200
        case 8: self = .baud230400
        case 9: self = .baud460800
        case 10: self = .baud576000
        case 11: self = .baud921600
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .baudDefault: return 0
        case .baud2400: return 1
        case .baud4800: return 2
        case .baud9600: return 3
        case .baud19200: return 4
        case .baud38400: return 5
        case .baud57600: return 6
        case .baud115200: return 7
        case .baud230400: return 8
        case .baud460800: return 9
        case .baud576000: return 10
        case .baud921600: return 11
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    ///
    /// TODO: REPLACE
    enum Serial_Mode: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case modeDefault // = 0
      case modeSimple // = 1
      case modeProto // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .modeDefault
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .modeDefault
        case 1: self = .modeSimple
        case 2: self = .modeProto
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .modeDefault: return 0
        case .modeSimple: return 1
        case .modeProto: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    ///
    /// TODO: REPLACE
    enum TelemetrySensorType: SwiftProtobuf.Enum {
      typealias RawValue = Int

      ///
      /// No external telemetry sensor
      case none // = 0

      ///
      /// TODO: REPLACE
      case dht11 // = 1

      ///
      /// TODO: REPLACE
      case ds18B20 // = 2

      ///
      /// TODO: REPLACE
      case dht12 // = 3

      ///
      /// TODO: REPLACE
      case dht21 // = 4

      ///
      /// TODO: REPLACE
      case dht22 // = 5

      ///
      /// TODO: REPLACE
      case bme280 // = 6

      ///
      /// TODO: REPLACE
      case bme680 // = 7

      ///
      /// TODO: REPLACE
      case mcp9808 // = 8

      ///
      /// TODO: REPLACE
      case shtc3 // = 9
      case UNRECOGNIZED(Int)

      init() {
        self = .none
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .none
        case 1: self = .dht11
        case 2: self = .ds18B20
        case 3: self = .dht12
        case 4: self = .dht21
        case 5: self = .dht22
        case 6: self = .bme280
        case 7: self = .bme680
        case 8: self = .mcp9808
        case 9: self = .shtc3
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .none: return 0
        case .dht11: return 1
        case .ds18B20: return 2
        case .dht12: return 3
        case .dht21: return 4
        case .dht22: return 5
        case .bme280: return 6
        case .bme680: return 7
        case .mcp9808: return 8
        case .shtc3: return 9
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _preferences: RadioConfig.UserPreferences? = nil
}

#if swift(>=4.2)

extension RadioConfig.UserPreferences.Serial_Baud: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RadioConfig.UserPreferences.Serial_Baud] = [
    .baudDefault,
    .baud2400,
    .baud4800,
    .baud9600,
    .baud19200,
    .baud38400,
    .baud57600,
    .baud115200,
    .baud230400,
    .baud460800,
    .baud576000,
    .baud921600,
  ]
}

extension RadioConfig.UserPreferences.Serial_Mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RadioConfig.UserPreferences.Serial_Mode] = [
    .modeDefault,
    .modeSimple,
    .modeProto,
  ]
}

extension RadioConfig.UserPreferences.TelemetrySensorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RadioConfig.UserPreferences.TelemetrySensorType] = [
    .none,
    .dht11,
    .ds18B20,
    .dht12,
    .dht21,
    .dht22,
    .bme280,
    .bme680,
    .mcp9808,
    .shtc3,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension RegionCode: @unchecked Sendable {}
extension Role: @unchecked Sendable {}
extension ChargeCurrent: @unchecked Sendable {}
extension GpsCoordinateFormat: @unchecked Sendable {}
extension PositionFlags: @unchecked Sendable {}
extension InputEventChar: @unchecked Sendable {}
extension RadioConfig: @unchecked Sendable {}
extension RadioConfig.UserPreferences: @unchecked Sendable {}
extension RadioConfig.UserPreferences.Serial_Baud: @unchecked Sendable {}
extension RadioConfig.UserPreferences.Serial_Mode: @unchecked Sendable {}
extension RadioConfig.UserPreferences.TelemetrySensorType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension RegionCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unset"),
    1: .same(proto: "US"),
    2: .same(proto: "EU433"),
    3: .same(proto: "EU868"),
    4: .same(proto: "CN"),
    5: .same(proto: "JP"),
    6: .same(proto: "ANZ"),
    7: .same(proto: "KR"),
    8: .same(proto: "TW"),
    9: .same(proto: "RU"),
    10: .same(proto: "IN"),
    11: .same(proto: "NZ865"),
    12: .same(proto: "TH"),
  ]
}

extension Role: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Client"),
    1: .same(proto: "ClientMute"),
    2: .same(proto: "Router"),
    3: .same(proto: "RouterClient"),
  ]
}

extension ChargeCurrent: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAUnset"),
    1: .same(proto: "MA100"),
    2: .same(proto: "MA190"),
    3: .same(proto: "MA280"),
    4: .same(proto: "MA360"),
    5: .same(proto: "MA450"),
    6: .same(proto: "MA550"),
    7: .same(proto: "MA630"),
    8: .same(proto: "MA700"),
    9: .same(proto: "MA780"),
    10: .same(proto: "MA880"),
    11: .same(proto: "MA960"),
    12: .same(proto: "MA1000"),
    13: .same(proto: "MA1080"),
    14: .same(proto: "MA1160"),
    15: .same(proto: "MA1240"),
    16: .same(proto: "MA1320"),
  ]
}

extension GpsCoordinateFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GpsFormatDec"),
    1: .same(proto: "GpsFormatDMS"),
    2: .same(proto: "GpsFormatUTM"),
    3: .same(proto: "GpsFormatMGRS"),
    4: .same(proto: "GpsFormatOLC"),
    5: .same(proto: "GpsFormatOSGR"),
  ]
}

extension PositionFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POS_UNDEFINED"),
    1: .same(proto: "POS_ALTITUDE"),
    2: .same(proto: "POS_ALT_MSL"),
    4: .same(proto: "POS_GEO_SEP"),
    8: .same(proto: "POS_DOP"),
    16: .same(proto: "POS_HVDOP"),
    32: .same(proto: "POS_BATTERY"),
    64: .same(proto: "POS_SATINVIEW"),
    128: .same(proto: "POS_SEQ_NOS"),
    256: .same(proto: "POS_TIMESTAMP"),
  ]
}

extension InputEventChar: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_NONE"),
    10: .same(proto: "KEY_SELECT"),
    17: .same(proto: "KEY_UP"),
    18: .same(proto: "KEY_DOWN"),
    19: .same(proto: "KEY_LEFT"),
    20: .same(proto: "KEY_RIGHT"),
    24: .same(proto: "KEY_CANCEL"),
    27: .same(proto: "KEY_BACK"),
  ]
}

extension RadioConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RadioConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preferences"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._preferences) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._preferences {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RadioConfig, rhs: RadioConfig) -> Bool {
    if lhs._preferences != rhs._preferences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RadioConfig.UserPreferences: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RadioConfig.protoMessageName + ".UserPreferences"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "position_broadcast_secs"),
    17: .standard(proto: "position_broadcast_smart_disabled"),
    4: .standard(proto: "wait_bluetooth_secs"),
    5: .standard(proto: "screen_on_secs"),
    6: .standard(proto: "phone_timeout_secs"),
    7: .standard(proto: "phone_sds_timeout_sec"),
    8: .standard(proto: "mesh_sds_timeout_secs"),
    9: .standard(proto: "sds_secs"),
    10: .standard(proto: "ls_secs"),
    11: .standard(proto: "min_wake_secs"),
    12: .standard(proto: "wifi_ssid"),
    13: .standard(proto: "wifi_password"),
    14: .standard(proto: "wifi_ap_mode"),
    15: .same(proto: "region"),
    16: .standard(proto: "charge_current"),
    18: .same(proto: "role"),
    38: .standard(proto: "is_low_power"),
    39: .standard(proto: "fixed_position"),
    40: .standard(proto: "serial_disabled"),
    32: .standard(proto: "location_share_disabled"),
    33: .standard(proto: "gps_disabled"),
    34: .standard(proto: "gps_update_interval"),
    36: .standard(proto: "gps_attempt_time"),
    45: .standard(proto: "gps_accept_2d"),
    46: .standard(proto: "gps_max_dop"),
    41: .standard(proto: "frequency_offset"),
    42: .standard(proto: "mqtt_server"),
    43: .standard(proto: "mqtt_disabled"),
    44: .standard(proto: "gps_format"),
    100: .standard(proto: "factory_reset"),
    101: .standard(proto: "debug_log_enabled"),
    103: .standard(proto: "ignore_incoming"),
    120: .standard(proto: "serial_module_enabled"),
    121: .standard(proto: "serial_module_echo"),
    122: .standard(proto: "serial_module_rxd"),
    123: .standard(proto: "serial_module_txd"),
    176: .standard(proto: "serial_module_baud"),
    124: .standard(proto: "serial_module_timeout"),
    125: .standard(proto: "serial_module_mode"),
    126: .standard(proto: "ext_notification_module_enabled"),
    127: .standard(proto: "ext_notification_module_output_ms"),
    128: .standard(proto: "ext_notification_module_output"),
    129: .standard(proto: "ext_notification_module_active"),
    130: .standard(proto: "ext_notification_module_alert_message"),
    131: .standard(proto: "ext_notification_module_alert_bell"),
    132: .standard(proto: "range_test_module_enabled"),
    133: .standard(proto: "range_test_module_sender"),
    134: .standard(proto: "range_test_module_save"),
    148: .standard(proto: "store_forward_module_enabled"),
    149: .standard(proto: "store_forward_module_heartbeat"),
    137: .standard(proto: "store_forward_module_records"),
    138: .standard(proto: "store_forward_module_history_return_max"),
    139: .standard(proto: "store_forward_module_history_return_window"),
    140: .standard(proto: "telemetry_module_environment_measurement_enabled"),
    141: .standard(proto: "telemetry_module_environment_screen_enabled"),
    142: .standard(proto: "telemetry_module_environment_read_error_count_threshold"),
    143: .standard(proto: "telemetry_module_device_update_interval"),
    144: .standard(proto: "telemetry_module_environment_recovery_interval"),
    145: .standard(proto: "telemetry_module_environment_display_fahrenheit"),
    146: .standard(proto: "telemetry_module_environment_sensor_type"),
    147: .standard(proto: "telemetry_module_environment_sensor_pin"),
    150: .standard(proto: "position_flags"),
    151: .standard(proto: "is_always_powered"),
    152: .standard(proto: "auto_screen_carousel_secs"),
    153: .standard(proto: "on_battery_shutdown_after_secs"),
    154: .standard(proto: "hop_limit"),
    155: .standard(proto: "mqtt_username"),
    156: .standard(proto: "mqtt_password"),
    157: .standard(proto: "is_lora_tx_disabled"),
    158: .standard(proto: "is_power_saving"),
    160: .standard(proto: "rotary1_enabled"),
    161: .standard(proto: "inputbroker_pin_a"),
    162: .standard(proto: "inputbroker_pin_b"),
    163: .standard(proto: "inputbroker_pin_press"),
    164: .standard(proto: "inputbroker_event_cw"),
    165: .standard(proto: "inputbroker_event_ccw"),
    166: .standard(proto: "inputbroker_event_press"),
    167: .standard(proto: "updown1_enabled"),
    170: .standard(proto: "canned_message_module_enabled"),
    171: .standard(proto: "canned_message_module_allow_input_source"),
    173: .standard(proto: "canned_message_module_send_bell"),
    174: .standard(proto: "mqtt_encryption_enabled"),
    175: .standard(proto: "adc_multiplier_override"),
    177: .standard(proto: "telemetry_module_environment_update_interval"),
  ]

  fileprivate class _StorageClass {
    var _positionBroadcastSecs: UInt32 = 0
    var _positionBroadcastSmartDisabled: Bool = false
    var _waitBluetoothSecs: UInt32 = 0
    var _screenOnSecs: UInt32 = 0
    var _phoneTimeoutSecs: UInt32 = 0
    var _phoneSdsTimeoutSec: UInt32 = 0
    var _meshSdsTimeoutSecs: UInt32 = 0
    var _sdsSecs: UInt32 = 0
    var _lsSecs: UInt32 = 0
    var _minWakeSecs: UInt32 = 0
    var _wifiSsid: String = String()
    var _wifiPassword: String = String()
    var _wifiApMode: Bool = false
    var _region: RegionCode = .unset
    var _chargeCurrent: ChargeCurrent = .maunset
    var _role: Role = .client
    var _isLowPower: Bool = false
    var _fixedPosition: Bool = false
    var _serialDisabled: Bool = false
    var _locationShareDisabled: Bool = false
    var _gpsDisabled: Bool = false
    var _gpsUpdateInterval: UInt32 = 0
    var _gpsAttemptTime: UInt32 = 0
    var _gpsAccept2D: Bool = false
    var _gpsMaxDop: UInt32 = 0
    var _frequencyOffset: Float = 0
    var _mqttServer: String = String()
    var _mqttDisabled: Bool = false
    var _gpsFormat: GpsCoordinateFormat = .gpsFormatDec
    var _factoryReset: Bool = false
    var _debugLogEnabled: Bool = false
    var _ignoreIncoming: [UInt32] = []
    var _serialModuleEnabled: Bool = false
    var _serialModuleEcho: Bool = false
    var _serialModuleRxd: UInt32 = 0
    var _serialModuleTxd: UInt32 = 0
    var _serialModuleBaud: RadioConfig.UserPreferences.Serial_Baud = .baudDefault
    var _serialModuleTimeout: UInt32 = 0
    var _serialModuleMode: RadioConfig.UserPreferences.Serial_Mode = .modeDefault
    var _extNotificationModuleEnabled: Bool = false
    var _extNotificationModuleOutputMs: UInt32 = 0
    var _extNotificationModuleOutput: UInt32 = 0
    var _extNotificationModuleActive: Bool = false
    var _extNotificationModuleAlertMessage: Bool = false
    var _extNotificationModuleAlertBell: Bool = false
    var _rangeTestModuleEnabled: Bool = false
    var _rangeTestModuleSender: UInt32 = 0
    var _rangeTestModuleSave: Bool = false
    var _storeForwardModuleEnabled: Bool = false
    var _storeForwardModuleHeartbeat: Bool = false
    var _storeForwardModuleRecords: UInt32 = 0
    var _storeForwardModuleHistoryReturnMax: UInt32 = 0
    var _storeForwardModuleHistoryReturnWindow: UInt32 = 0
    var _telemetryModuleEnvironmentMeasurementEnabled: Bool = false
    var _telemetryModuleEnvironmentScreenEnabled: Bool = false
    var _telemetryModuleEnvironmentReadErrorCountThreshold: UInt32 = 0
    var _telemetryModuleDeviceUpdateInterval: UInt32 = 0
    var _telemetryModuleEnvironmentRecoveryInterval: UInt32 = 0
    var _telemetryModuleEnvironmentDisplayFahrenheit: Bool = false
    var _telemetryModuleEnvironmentSensorType: RadioConfig.UserPreferences.TelemetrySensorType = .none
    var _telemetryModuleEnvironmentSensorPin: UInt32 = 0
    var _positionFlags: UInt32 = 0
    var _isAlwaysPowered: Bool = false
    var _autoScreenCarouselSecs: UInt32 = 0
    var _onBatteryShutdownAfterSecs: UInt32 = 0
    var _hopLimit: UInt32 = 0
    var _mqttUsername: String = String()
    var _mqttPassword: String = String()
    var _isLoraTxDisabled: Bool = false
    var _isPowerSaving: Bool = false
    var _rotary1Enabled: Bool = false
    var _inputbrokerPinA: UInt32 = 0
    var _inputbrokerPinB: UInt32 = 0
    var _inputbrokerPinPress: UInt32 = 0
    var _inputbrokerEventCw: InputEventChar = .keyNone
    var _inputbrokerEventCcw: InputEventChar = .keyNone
    var _inputbrokerEventPress: InputEventChar = .keyNone
    var _updown1Enabled: Bool = false
    var _cannedMessageModuleEnabled: Bool = false
    var _cannedMessageModuleAllowInputSource: String = String()
    var _cannedMessageModuleSendBell: Bool = false
    var _mqttEncryptionEnabled: Bool = false
    var _adcMultiplierOverride: Float = 0
    var _telemetryModuleEnvironmentUpdateInterval: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _positionBroadcastSecs = source._positionBroadcastSecs
      _positionBroadcastSmartDisabled = source._positionBroadcastSmartDisabled
      _waitBluetoothSecs = source._waitBluetoothSecs
      _screenOnSecs = source._screenOnSecs
      _phoneTimeoutSecs = source._phoneTimeoutSecs
      _phoneSdsTimeoutSec = source._phoneSdsTimeoutSec
      _meshSdsTimeoutSecs = source._meshSdsTimeoutSecs
      _sdsSecs = source._sdsSecs
      _lsSecs = source._lsSecs
      _minWakeSecs = source._minWakeSecs
      _wifiSsid = source._wifiSsid
      _wifiPassword = source._wifiPassword
      _wifiApMode = source._wifiApMode
      _region = source._region
      _chargeCurrent = source._chargeCurrent
      _role = source._role
      _isLowPower = source._isLowPower
      _fixedPosition = source._fixedPosition
      _serialDisabled = source._serialDisabled
      _locationShareDisabled = source._locationShareDisabled
      _gpsDisabled = source._gpsDisabled
      _gpsUpdateInterval = source._gpsUpdateInterval
      _gpsAttemptTime = source._gpsAttemptTime
      _gpsAccept2D = source._gpsAccept2D
      _gpsMaxDop = source._gpsMaxDop
      _frequencyOffset = source._frequencyOffset
      _mqttServer = source._mqttServer
      _mqttDisabled = source._mqttDisabled
      _gpsFormat = source._gpsFormat
      _factoryReset = source._factoryReset
      _debugLogEnabled = source._debugLogEnabled
      _ignoreIncoming = source._ignoreIncoming
      _serialModuleEnabled = source._serialModuleEnabled
      _serialModuleEcho = source._serialModuleEcho
      _serialModuleRxd = source._serialModuleRxd
      _serialModuleTxd = source._serialModuleTxd
      _serialModuleBaud = source._serialModuleBaud
      _serialModuleTimeout = source._serialModuleTimeout
      _serialModuleMode = source._serialModuleMode
      _extNotificationModuleEnabled = source._extNotificationModuleEnabled
      _extNotificationModuleOutputMs = source._extNotificationModuleOutputMs
      _extNotificationModuleOutput = source._extNotificationModuleOutput
      _extNotificationModuleActive = source._extNotificationModuleActive
      _extNotificationModuleAlertMessage = source._extNotificationModuleAlertMessage
      _extNotificationModuleAlertBell = source._extNotificationModuleAlertBell
      _rangeTestModuleEnabled = source._rangeTestModuleEnabled
      _rangeTestModuleSender = source._rangeTestModuleSender
      _rangeTestModuleSave = source._rangeTestModuleSave
      _storeForwardModuleEnabled = source._storeForwardModuleEnabled
      _storeForwardModuleHeartbeat = source._storeForwardModuleHeartbeat
      _storeForwardModuleRecords = source._storeForwardModuleRecords
      _storeForwardModuleHistoryReturnMax = source._storeForwardModuleHistoryReturnMax
      _storeForwardModuleHistoryReturnWindow = source._storeForwardModuleHistoryReturnWindow
      _telemetryModuleEnvironmentMeasurementEnabled = source._telemetryModuleEnvironmentMeasurementEnabled
      _telemetryModuleEnvironmentScreenEnabled = source._telemetryModuleEnvironmentScreenEnabled
      _telemetryModuleEnvironmentReadErrorCountThreshold = source._telemetryModuleEnvironmentReadErrorCountThreshold
      _telemetryModuleDeviceUpdateInterval = source._telemetryModuleDeviceUpdateInterval
      _telemetryModuleEnvironmentRecoveryInterval = source._telemetryModuleEnvironmentRecoveryInterval
      _telemetryModuleEnvironmentDisplayFahrenheit = source._telemetryModuleEnvironmentDisplayFahrenheit
      _telemetryModuleEnvironmentSensorType = source._telemetryModuleEnvironmentSensorType
      _telemetryModuleEnvironmentSensorPin = source._telemetryModuleEnvironmentSensorPin
      _positionFlags = source._positionFlags
      _isAlwaysPowered = source._isAlwaysPowered
      _autoScreenCarouselSecs = source._autoScreenCarouselSecs
      _onBatteryShutdownAfterSecs = source._onBatteryShutdownAfterSecs
      _hopLimit = source._hopLimit
      _mqttUsername = source._mqttUsername
      _mqttPassword = source._mqttPassword
      _isLoraTxDisabled = source._isLoraTxDisabled
      _isPowerSaving = source._isPowerSaving
      _rotary1Enabled = source._rotary1Enabled
      _inputbrokerPinA = source._inputbrokerPinA
      _inputbrokerPinB = source._inputbrokerPinB
      _inputbrokerPinPress = source._inputbrokerPinPress
      _inputbrokerEventCw = source._inputbrokerEventCw
      _inputbrokerEventCcw = source._inputbrokerEventCcw
      _inputbrokerEventPress = source._inputbrokerEventPress
      _updown1Enabled = source._updown1Enabled
      _cannedMessageModuleEnabled = source._cannedMessageModuleEnabled
      _cannedMessageModuleAllowInputSource = source._cannedMessageModuleAllowInputSource
      _cannedMessageModuleSendBell = source._cannedMessageModuleSendBell
      _mqttEncryptionEnabled = source._mqttEncryptionEnabled
      _adcMultiplierOverride = source._adcMultiplierOverride
      _telemetryModuleEnvironmentUpdateInterval = source._telemetryModuleEnvironmentUpdateInterval
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._positionBroadcastSecs) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._waitBluetoothSecs) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._screenOnSecs) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._phoneTimeoutSecs) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._phoneSdsTimeoutSec) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._meshSdsTimeoutSecs) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._sdsSecs) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._lsSecs) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._minWakeSecs) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._wifiSsid) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._wifiPassword) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._wifiApMode) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._region) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._chargeCurrent) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._positionBroadcastSmartDisabled) }()
        case 18: try { try decoder.decodeSingularEnumField(value: &_storage._role) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._locationShareDisabled) }()
        case 33: try { try decoder.decodeSingularBoolField(value: &_storage._gpsDisabled) }()
        case 34: try { try decoder.decodeSingularUInt32Field(value: &_storage._gpsUpdateInterval) }()
        case 36: try { try decoder.decodeSingularUInt32Field(value: &_storage._gpsAttemptTime) }()
        case 38: try { try decoder.decodeSingularBoolField(value: &_storage._isLowPower) }()
        case 39: try { try decoder.decodeSingularBoolField(value: &_storage._fixedPosition) }()
        case 40: try { try decoder.decodeSingularBoolField(value: &_storage._serialDisabled) }()
        case 41: try { try decoder.decodeSingularFloatField(value: &_storage._frequencyOffset) }()
        case 42: try { try decoder.decodeSingularStringField(value: &_storage._mqttServer) }()
        case 43: try { try decoder.decodeSingularBoolField(value: &_storage._mqttDisabled) }()
        case 44: try { try decoder.decodeSingularEnumField(value: &_storage._gpsFormat) }()
        case 45: try { try decoder.decodeSingularBoolField(value: &_storage._gpsAccept2D) }()
        case 46: try { try decoder.decodeSingularUInt32Field(value: &_storage._gpsMaxDop) }()
        case 100: try { try decoder.decodeSingularBoolField(value: &_storage._factoryReset) }()
        case 101: try { try decoder.decodeSingularBoolField(value: &_storage._debugLogEnabled) }()
        case 103: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._ignoreIncoming) }()
        case 120: try { try decoder.decodeSingularBoolField(value: &_storage._serialModuleEnabled) }()
        case 121: try { try decoder.decodeSingularBoolField(value: &_storage._serialModuleEcho) }()
        case 122: try { try decoder.decodeSingularUInt32Field(value: &_storage._serialModuleRxd) }()
        case 123: try { try decoder.decodeSingularUInt32Field(value: &_storage._serialModuleTxd) }()
        case 124: try { try decoder.decodeSingularUInt32Field(value: &_storage._serialModuleTimeout) }()
        case 125: try { try decoder.decodeSingularEnumField(value: &_storage._serialModuleMode) }()
        case 126: try { try decoder.decodeSingularBoolField(value: &_storage._extNotificationModuleEnabled) }()
        case 127: try { try decoder.decodeSingularUInt32Field(value: &_storage._extNotificationModuleOutputMs) }()
        case 128: try { try decoder.decodeSingularUInt32Field(value: &_storage._extNotificationModuleOutput) }()
        case 129: try { try decoder.decodeSingularBoolField(value: &_storage._extNotificationModuleActive) }()
        case 130: try { try decoder.decodeSingularBoolField(value: &_storage._extNotificationModuleAlertMessage) }()
        case 131: try { try decoder.decodeSingularBoolField(value: &_storage._extNotificationModuleAlertBell) }()
        case 132: try { try decoder.decodeSingularBoolField(value: &_storage._rangeTestModuleEnabled) }()
        case 133: try { try decoder.decodeSingularUInt32Field(value: &_storage._rangeTestModuleSender) }()
        case 134: try { try decoder.decodeSingularBoolField(value: &_storage._rangeTestModuleSave) }()
        case 137: try { try decoder.decodeSingularUInt32Field(value: &_storage._storeForwardModuleRecords) }()
        case 138: try { try decoder.decodeSingularUInt32Field(value: &_storage._storeForwardModuleHistoryReturnMax) }()
        case 139: try { try decoder.decodeSingularUInt32Field(value: &_storage._storeForwardModuleHistoryReturnWindow) }()
        case 140: try { try decoder.decodeSingularBoolField(value: &_storage._telemetryModuleEnvironmentMeasurementEnabled) }()
        case 141: try { try decoder.decodeSingularBoolField(value: &_storage._telemetryModuleEnvironmentScreenEnabled) }()
        case 142: try { try decoder.decodeSingularUInt32Field(value: &_storage._telemetryModuleEnvironmentReadErrorCountThreshold) }()
        case 143: try { try decoder.decodeSingularUInt32Field(value: &_storage._telemetryModuleDeviceUpdateInterval) }()
        case 144: try { try decoder.decodeSingularUInt32Field(value: &_storage._telemetryModuleEnvironmentRecoveryInterval) }()
        case 145: try { try decoder.decodeSingularBoolField(value: &_storage._telemetryModuleEnvironmentDisplayFahrenheit) }()
        case 146: try { try decoder.decodeSingularEnumField(value: &_storage._telemetryModuleEnvironmentSensorType) }()
        case 147: try { try decoder.decodeSingularUInt32Field(value: &_storage._telemetryModuleEnvironmentSensorPin) }()
        case 148: try { try decoder.decodeSingularBoolField(value: &_storage._storeForwardModuleEnabled) }()
        case 149: try { try decoder.decodeSingularBoolField(value: &_storage._storeForwardModuleHeartbeat) }()
        case 150: try { try decoder.decodeSingularUInt32Field(value: &_storage._positionFlags) }()
        case 151: try { try decoder.decodeSingularBoolField(value: &_storage._isAlwaysPowered) }()
        case 152: try { try decoder.decodeSingularUInt32Field(value: &_storage._autoScreenCarouselSecs) }()
        case 153: try { try decoder.decodeSingularUInt32Field(value: &_storage._onBatteryShutdownAfterSecs) }()
        case 154: try { try decoder.decodeSingularUInt32Field(value: &_storage._hopLimit) }()
        case 155: try { try decoder.decodeSingularStringField(value: &_storage._mqttUsername) }()
        case 156: try { try decoder.decodeSingularStringField(value: &_storage._mqttPassword) }()
        case 157: try { try decoder.decodeSingularBoolField(value: &_storage._isLoraTxDisabled) }()
        case 158: try { try decoder.decodeSingularBoolField(value: &_storage._isPowerSaving) }()
        case 160: try { try decoder.decodeSingularBoolField(value: &_storage._rotary1Enabled) }()
        case 161: try { try decoder.decodeSingularUInt32Field(value: &_storage._inputbrokerPinA) }()
        case 162: try { try decoder.decodeSingularUInt32Field(value: &_storage._inputbrokerPinB) }()
        case 163: try { try decoder.decodeSingularUInt32Field(value: &_storage._inputbrokerPinPress) }()
        case 164: try { try decoder.decodeSingularEnumField(value: &_storage._inputbrokerEventCw) }()
        case 165: try { try decoder.decodeSingularEnumField(value: &_storage._inputbrokerEventCcw) }()
        case 166: try { try decoder.decodeSingularEnumField(value: &_storage._inputbrokerEventPress) }()
        case 167: try { try decoder.decodeSingularBoolField(value: &_storage._updown1Enabled) }()
        case 170: try { try decoder.decodeSingularBoolField(value: &_storage._cannedMessageModuleEnabled) }()
        case 171: try { try decoder.decodeSingularStringField(value: &_storage._cannedMessageModuleAllowInputSource) }()
        case 173: try { try decoder.decodeSingularBoolField(value: &_storage._cannedMessageModuleSendBell) }()
        case 174: try { try decoder.decodeSingularBoolField(value: &_storage._mqttEncryptionEnabled) }()
        case 175: try { try decoder.decodeSingularFloatField(value: &_storage._adcMultiplierOverride) }()
        case 176: try { try decoder.decodeSingularEnumField(value: &_storage._serialModuleBaud) }()
        case 177: try { try decoder.decodeSingularUInt32Field(value: &_storage._telemetryModuleEnvironmentUpdateInterval) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._positionBroadcastSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._positionBroadcastSecs, fieldNumber: 1)
      }
      if _storage._waitBluetoothSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._waitBluetoothSecs, fieldNumber: 4)
      }
      if _storage._screenOnSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._screenOnSecs, fieldNumber: 5)
      }
      if _storage._phoneTimeoutSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._phoneTimeoutSecs, fieldNumber: 6)
      }
      if _storage._phoneSdsTimeoutSec != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._phoneSdsTimeoutSec, fieldNumber: 7)
      }
      if _storage._meshSdsTimeoutSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._meshSdsTimeoutSecs, fieldNumber: 8)
      }
      if _storage._sdsSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._sdsSecs, fieldNumber: 9)
      }
      if _storage._lsSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lsSecs, fieldNumber: 10)
      }
      if _storage._minWakeSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minWakeSecs, fieldNumber: 11)
      }
      if !_storage._wifiSsid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._wifiSsid, fieldNumber: 12)
      }
      if !_storage._wifiPassword.isEmpty {
        try visitor.visitSingularStringField(value: _storage._wifiPassword, fieldNumber: 13)
      }
      if _storage._wifiApMode != false {
        try visitor.visitSingularBoolField(value: _storage._wifiApMode, fieldNumber: 14)
      }
      if _storage._region != .unset {
        try visitor.visitSingularEnumField(value: _storage._region, fieldNumber: 15)
      }
      if _storage._chargeCurrent != .maunset {
        try visitor.visitSingularEnumField(value: _storage._chargeCurrent, fieldNumber: 16)
      }
      if _storage._positionBroadcastSmartDisabled != false {
        try visitor.visitSingularBoolField(value: _storage._positionBroadcastSmartDisabled, fieldNumber: 17)
      }
      if _storage._role != .client {
        try visitor.visitSingularEnumField(value: _storage._role, fieldNumber: 18)
      }
      if _storage._locationShareDisabled != false {
        try visitor.visitSingularBoolField(value: _storage._locationShareDisabled, fieldNumber: 32)
      }
      if _storage._gpsDisabled != false {
        try visitor.visitSingularBoolField(value: _storage._gpsDisabled, fieldNumber: 33)
      }
      if _storage._gpsUpdateInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._gpsUpdateInterval, fieldNumber: 34)
      }
      if _storage._gpsAttemptTime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._gpsAttemptTime, fieldNumber: 36)
      }
      if _storage._isLowPower != false {
        try visitor.visitSingularBoolField(value: _storage._isLowPower, fieldNumber: 38)
      }
      if _storage._fixedPosition != false {
        try visitor.visitSingularBoolField(value: _storage._fixedPosition, fieldNumber: 39)
      }
      if _storage._serialDisabled != false {
        try visitor.visitSingularBoolField(value: _storage._serialDisabled, fieldNumber: 40)
      }
      if _storage._frequencyOffset != 0 {
        try visitor.visitSingularFloatField(value: _storage._frequencyOffset, fieldNumber: 41)
      }
      if !_storage._mqttServer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mqttServer, fieldNumber: 42)
      }
      if _storage._mqttDisabled != false {
        try visitor.visitSingularBoolField(value: _storage._mqttDisabled, fieldNumber: 43)
      }
      if _storage._gpsFormat != .gpsFormatDec {
        try visitor.visitSingularEnumField(value: _storage._gpsFormat, fieldNumber: 44)
      }
      if _storage._gpsAccept2D != false {
        try visitor.visitSingularBoolField(value: _storage._gpsAccept2D, fieldNumber: 45)
      }
      if _storage._gpsMaxDop != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._gpsMaxDop, fieldNumber: 46)
      }
      if _storage._factoryReset != false {
        try visitor.visitSingularBoolField(value: _storage._factoryReset, fieldNumber: 100)
      }
      if _storage._debugLogEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._debugLogEnabled, fieldNumber: 101)
      }
      if !_storage._ignoreIncoming.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._ignoreIncoming, fieldNumber: 103)
      }
      if _storage._serialModuleEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._serialModuleEnabled, fieldNumber: 120)
      }
      if _storage._serialModuleEcho != false {
        try visitor.visitSingularBoolField(value: _storage._serialModuleEcho, fieldNumber: 121)
      }
      if _storage._serialModuleRxd != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._serialModuleRxd, fieldNumber: 122)
      }
      if _storage._serialModuleTxd != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._serialModuleTxd, fieldNumber: 123)
      }
      if _storage._serialModuleTimeout != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._serialModuleTimeout, fieldNumber: 124)
      }
      if _storage._serialModuleMode != .modeDefault {
        try visitor.visitSingularEnumField(value: _storage._serialModuleMode, fieldNumber: 125)
      }
      if _storage._extNotificationModuleEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._extNotificationModuleEnabled, fieldNumber: 126)
      }
      if _storage._extNotificationModuleOutputMs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._extNotificationModuleOutputMs, fieldNumber: 127)
      }
      if _storage._extNotificationModuleOutput != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._extNotificationModuleOutput, fieldNumber: 128)
      }
      if _storage._extNotificationModuleActive != false {
        try visitor.visitSingularBoolField(value: _storage._extNotificationModuleActive, fieldNumber: 129)
      }
      if _storage._extNotificationModuleAlertMessage != false {
        try visitor.visitSingularBoolField(value: _storage._extNotificationModuleAlertMessage, fieldNumber: 130)
      }
      if _storage._extNotificationModuleAlertBell != false {
        try visitor.visitSingularBoolField(value: _storage._extNotificationModuleAlertBell, fieldNumber: 131)
      }
      if _storage._rangeTestModuleEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._rangeTestModuleEnabled, fieldNumber: 132)
      }
      if _storage._rangeTestModuleSender != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rangeTestModuleSender, fieldNumber: 133)
      }
      if _storage._rangeTestModuleSave != false {
        try visitor.visitSingularBoolField(value: _storage._rangeTestModuleSave, fieldNumber: 134)
      }
      if _storage._storeForwardModuleRecords != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._storeForwardModuleRecords, fieldNumber: 137)
      }
      if _storage._storeForwardModuleHistoryReturnMax != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._storeForwardModuleHistoryReturnMax, fieldNumber: 138)
      }
      if _storage._storeForwardModuleHistoryReturnWindow != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._storeForwardModuleHistoryReturnWindow, fieldNumber: 139)
      }
      if _storage._telemetryModuleEnvironmentMeasurementEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._telemetryModuleEnvironmentMeasurementEnabled, fieldNumber: 140)
      }
      if _storage._telemetryModuleEnvironmentScreenEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._telemetryModuleEnvironmentScreenEnabled, fieldNumber: 141)
      }
      if _storage._telemetryModuleEnvironmentReadErrorCountThreshold != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._telemetryModuleEnvironmentReadErrorCountThreshold, fieldNumber: 142)
      }
      if _storage._telemetryModuleDeviceUpdateInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._telemetryModuleDeviceUpdateInterval, fieldNumber: 143)
      }
      if _storage._telemetryModuleEnvironmentRecoveryInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._telemetryModuleEnvironmentRecoveryInterval, fieldNumber: 144)
      }
      if _storage._telemetryModuleEnvironmentDisplayFahrenheit != false {
        try visitor.visitSingularBoolField(value: _storage._telemetryModuleEnvironmentDisplayFahrenheit, fieldNumber: 145)
      }
      if _storage._telemetryModuleEnvironmentSensorType != .none {
        try visitor.visitSingularEnumField(value: _storage._telemetryModuleEnvironmentSensorType, fieldNumber: 146)
      }
      if _storage._telemetryModuleEnvironmentSensorPin != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._telemetryModuleEnvironmentSensorPin, fieldNumber: 147)
      }
      if _storage._storeForwardModuleEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._storeForwardModuleEnabled, fieldNumber: 148)
      }
      if _storage._storeForwardModuleHeartbeat != false {
        try visitor.visitSingularBoolField(value: _storage._storeForwardModuleHeartbeat, fieldNumber: 149)
      }
      if _storage._positionFlags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._positionFlags, fieldNumber: 150)
      }
      if _storage._isAlwaysPowered != false {
        try visitor.visitSingularBoolField(value: _storage._isAlwaysPowered, fieldNumber: 151)
      }
      if _storage._autoScreenCarouselSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._autoScreenCarouselSecs, fieldNumber: 152)
      }
      if _storage._onBatteryShutdownAfterSecs != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._onBatteryShutdownAfterSecs, fieldNumber: 153)
      }
      if _storage._hopLimit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hopLimit, fieldNumber: 154)
      }
      if !_storage._mqttUsername.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mqttUsername, fieldNumber: 155)
      }
      if !_storage._mqttPassword.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mqttPassword, fieldNumber: 156)
      }
      if _storage._isLoraTxDisabled != false {
        try visitor.visitSingularBoolField(value: _storage._isLoraTxDisabled, fieldNumber: 157)
      }
      if _storage._isPowerSaving != false {
        try visitor.visitSingularBoolField(value: _storage._isPowerSaving, fieldNumber: 158)
      }
      if _storage._rotary1Enabled != false {
        try visitor.visitSingularBoolField(value: _storage._rotary1Enabled, fieldNumber: 160)
      }
      if _storage._inputbrokerPinA != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._inputbrokerPinA, fieldNumber: 161)
      }
      if _storage._inputbrokerPinB != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._inputbrokerPinB, fieldNumber: 162)
      }
      if _storage._inputbrokerPinPress != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._inputbrokerPinPress, fieldNumber: 163)
      }
      if _storage._inputbrokerEventCw != .keyNone {
        try visitor.visitSingularEnumField(value: _storage._inputbrokerEventCw, fieldNumber: 164)
      }
      if _storage._inputbrokerEventCcw != .keyNone {
        try visitor.visitSingularEnumField(value: _storage._inputbrokerEventCcw, fieldNumber: 165)
      }
      if _storage._inputbrokerEventPress != .keyNone {
        try visitor.visitSingularEnumField(value: _storage._inputbrokerEventPress, fieldNumber: 166)
      }
      if _storage._updown1Enabled != false {
        try visitor.visitSingularBoolField(value: _storage._updown1Enabled, fieldNumber: 167)
      }
      if _storage._cannedMessageModuleEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._cannedMessageModuleEnabled, fieldNumber: 170)
      }
      if !_storage._cannedMessageModuleAllowInputSource.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cannedMessageModuleAllowInputSource, fieldNumber: 171)
      }
      if _storage._cannedMessageModuleSendBell != false {
        try visitor.visitSingularBoolField(value: _storage._cannedMessageModuleSendBell, fieldNumber: 173)
      }
      if _storage._mqttEncryptionEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._mqttEncryptionEnabled, fieldNumber: 174)
      }
      if _storage._adcMultiplierOverride != 0 {
        try visitor.visitSingularFloatField(value: _storage._adcMultiplierOverride, fieldNumber: 175)
      }
      if _storage._serialModuleBaud != .baudDefault {
        try visitor.visitSingularEnumField(value: _storage._serialModuleBaud, fieldNumber: 176)
      }
      if _storage._telemetryModuleEnvironmentUpdateInterval != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._telemetryModuleEnvironmentUpdateInterval, fieldNumber: 177)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RadioConfig.UserPreferences, rhs: RadioConfig.UserPreferences) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._positionBroadcastSecs != rhs_storage._positionBroadcastSecs {return false}
        if _storage._positionBroadcastSmartDisabled != rhs_storage._positionBroadcastSmartDisabled {return false}
        if _storage._waitBluetoothSecs != rhs_storage._waitBluetoothSecs {return false}
        if _storage._screenOnSecs != rhs_storage._screenOnSecs {return false}
        if _storage._phoneTimeoutSecs != rhs_storage._phoneTimeoutSecs {return false}
        if _storage._phoneSdsTimeoutSec != rhs_storage._phoneSdsTimeoutSec {return false}
        if _storage._meshSdsTimeoutSecs != rhs_storage._meshSdsTimeoutSecs {return false}
        if _storage._sdsSecs != rhs_storage._sdsSecs {return false}
        if _storage._lsSecs != rhs_storage._lsSecs {return false}
        if _storage._minWakeSecs != rhs_storage._minWakeSecs {return false}
        if _storage._wifiSsid != rhs_storage._wifiSsid {return false}
        if _storage._wifiPassword != rhs_storage._wifiPassword {return false}
        if _storage._wifiApMode != rhs_storage._wifiApMode {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._chargeCurrent != rhs_storage._chargeCurrent {return false}
        if _storage._role != rhs_storage._role {return false}
        if _storage._isLowPower != rhs_storage._isLowPower {return false}
        if _storage._fixedPosition != rhs_storage._fixedPosition {return false}
        if _storage._serialDisabled != rhs_storage._serialDisabled {return false}
        if _storage._locationShareDisabled != rhs_storage._locationShareDisabled {return false}
        if _storage._gpsDisabled != rhs_storage._gpsDisabled {return false}
        if _storage._gpsUpdateInterval != rhs_storage._gpsUpdateInterval {return false}
        if _storage._gpsAttemptTime != rhs_storage._gpsAttemptTime {return false}
        if _storage._gpsAccept2D != rhs_storage._gpsAccept2D {return false}
        if _storage._gpsMaxDop != rhs_storage._gpsMaxDop {return false}
        if _storage._frequencyOffset != rhs_storage._frequencyOffset {return false}
        if _storage._mqttServer != rhs_storage._mqttServer {return false}
        if _storage._mqttDisabled != rhs_storage._mqttDisabled {return false}
        if _storage._gpsFormat != rhs_storage._gpsFormat {return false}
        if _storage._factoryReset != rhs_storage._factoryReset {return false}
        if _storage._debugLogEnabled != rhs_storage._debugLogEnabled {return false}
        if _storage._ignoreIncoming != rhs_storage._ignoreIncoming {return false}
        if _storage._serialModuleEnabled != rhs_storage._serialModuleEnabled {return false}
        if _storage._serialModuleEcho != rhs_storage._serialModuleEcho {return false}
        if _storage._serialModuleRxd != rhs_storage._serialModuleRxd {return false}
        if _storage._serialModuleTxd != rhs_storage._serialModuleTxd {return false}
        if _storage._serialModuleBaud != rhs_storage._serialModuleBaud {return false}
        if _storage._serialModuleTimeout != rhs_storage._serialModuleTimeout {return false}
        if _storage._serialModuleMode != rhs_storage._serialModuleMode {return false}
        if _storage._extNotificationModuleEnabled != rhs_storage._extNotificationModuleEnabled {return false}
        if _storage._extNotificationModuleOutputMs != rhs_storage._extNotificationModuleOutputMs {return false}
        if _storage._extNotificationModuleOutput != rhs_storage._extNotificationModuleOutput {return false}
        if _storage._extNotificationModuleActive != rhs_storage._extNotificationModuleActive {return false}
        if _storage._extNotificationModuleAlertMessage != rhs_storage._extNotificationModuleAlertMessage {return false}
        if _storage._extNotificationModuleAlertBell != rhs_storage._extNotificationModuleAlertBell {return false}
        if _storage._rangeTestModuleEnabled != rhs_storage._rangeTestModuleEnabled {return false}
        if _storage._rangeTestModuleSender != rhs_storage._rangeTestModuleSender {return false}
        if _storage._rangeTestModuleSave != rhs_storage._rangeTestModuleSave {return false}
        if _storage._storeForwardModuleEnabled != rhs_storage._storeForwardModuleEnabled {return false}
        if _storage._storeForwardModuleHeartbeat != rhs_storage._storeForwardModuleHeartbeat {return false}
        if _storage._storeForwardModuleRecords != rhs_storage._storeForwardModuleRecords {return false}
        if _storage._storeForwardModuleHistoryReturnMax != rhs_storage._storeForwardModuleHistoryReturnMax {return false}
        if _storage._storeForwardModuleHistoryReturnWindow != rhs_storage._storeForwardModuleHistoryReturnWindow {return false}
        if _storage._telemetryModuleEnvironmentMeasurementEnabled != rhs_storage._telemetryModuleEnvironmentMeasurementEnabled {return false}
        if _storage._telemetryModuleEnvironmentScreenEnabled != rhs_storage._telemetryModuleEnvironmentScreenEnabled {return false}
        if _storage._telemetryModuleEnvironmentReadErrorCountThreshold != rhs_storage._telemetryModuleEnvironmentReadErrorCountThreshold {return false}
        if _storage._telemetryModuleDeviceUpdateInterval != rhs_storage._telemetryModuleDeviceUpdateInterval {return false}
        if _storage._telemetryModuleEnvironmentRecoveryInterval != rhs_storage._telemetryModuleEnvironmentRecoveryInterval {return false}
        if _storage._telemetryModuleEnvironmentDisplayFahrenheit != rhs_storage._telemetryModuleEnvironmentDisplayFahrenheit {return false}
        if _storage._telemetryModuleEnvironmentSensorType != rhs_storage._telemetryModuleEnvironmentSensorType {return false}
        if _storage._telemetryModuleEnvironmentSensorPin != rhs_storage._telemetryModuleEnvironmentSensorPin {return false}
        if _storage._positionFlags != rhs_storage._positionFlags {return false}
        if _storage._isAlwaysPowered != rhs_storage._isAlwaysPowered {return false}
        if _storage._autoScreenCarouselSecs != rhs_storage._autoScreenCarouselSecs {return false}
        if _storage._onBatteryShutdownAfterSecs != rhs_storage._onBatteryShutdownAfterSecs {return false}
        if _storage._hopLimit != rhs_storage._hopLimit {return false}
        if _storage._mqttUsername != rhs_storage._mqttUsername {return false}
        if _storage._mqttPassword != rhs_storage._mqttPassword {return false}
        if _storage._isLoraTxDisabled != rhs_storage._isLoraTxDisabled {return false}
        if _storage._isPowerSaving != rhs_storage._isPowerSaving {return false}
        if _storage._rotary1Enabled != rhs_storage._rotary1Enabled {return false}
        if _storage._inputbrokerPinA != rhs_storage._inputbrokerPinA {return false}
        if _storage._inputbrokerPinB != rhs_storage._inputbrokerPinB {return false}
        if _storage._inputbrokerPinPress != rhs_storage._inputbrokerPinPress {return false}
        if _storage._inputbrokerEventCw != rhs_storage._inputbrokerEventCw {return false}
        if _storage._inputbrokerEventCcw != rhs_storage._inputbrokerEventCcw {return false}
        if _storage._inputbrokerEventPress != rhs_storage._inputbrokerEventPress {return false}
        if _storage._updown1Enabled != rhs_storage._updown1Enabled {return false}
        if _storage._cannedMessageModuleEnabled != rhs_storage._cannedMessageModuleEnabled {return false}
        if _storage._cannedMessageModuleAllowInputSource != rhs_storage._cannedMessageModuleAllowInputSource {return false}
        if _storage._cannedMessageModuleSendBell != rhs_storage._cannedMessageModuleSendBell {return false}
        if _storage._mqttEncryptionEnabled != rhs_storage._mqttEncryptionEnabled {return false}
        if _storage._adcMultiplierOverride != rhs_storage._adcMultiplierOverride {return false}
        if _storage._telemetryModuleEnvironmentUpdateInterval != rhs_storage._telemetryModuleEnvironmentUpdateInterval {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RadioConfig.UserPreferences.Serial_Baud: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BAUD_Default"),
    1: .same(proto: "BAUD_2400"),
    2: .same(proto: "BAUD_4800"),
    3: .same(proto: "BAUD_9600"),
    4: .same(proto: "BAUD_19200"),
    5: .same(proto: "BAUD_38400"),
    6: .same(proto: "BAUD_57600"),
    7: .same(proto: "BAUD_115200"),
    8: .same(proto: "BAUD_230400"),
    9: .same(proto: "BAUD_460800"),
    10: .same(proto: "BAUD_576000"),
    11: .same(proto: "BAUD_921600"),
  ]
}

extension RadioConfig.UserPreferences.Serial_Mode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODE_Default"),
    1: .same(proto: "MODE_SIMPLE"),
    2: .same(proto: "MODE_PROTO"),
  ]
}

extension RadioConfig.UserPreferences.TelemetrySensorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "None"),
    1: .same(proto: "DHT11"),
    2: .same(proto: "DS18B20"),
    3: .same(proto: "DHT12"),
    4: .same(proto: "DHT21"),
    5: .same(proto: "DHT22"),
    6: .same(proto: "BME280"),
    7: .same(proto: "BME680"),
    8: .same(proto: "MCP9808"),
    9: .same(proto: "SHTC3"),
  ]
}
