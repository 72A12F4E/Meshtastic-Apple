// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: storeforward.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct StoreAndForwardMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rr: StoreAndForwardMessage.RequestResponse = .unset

  var stats: StoreAndForwardMessage.Statistics {
    get {return _stats ?? StoreAndForwardMessage.Statistics()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  mutating func clearStats() {self._stats = nil}

  var history: StoreAndForwardMessage.History {
    get {return _history ?? StoreAndForwardMessage.History()}
    set {_history = newValue}
  }
  /// Returns true if `history` has been explicitly set.
  var hasHistory: Bool {return self._history != nil}
  /// Clears the value of `history`. Subsequent reads from it will return its default value.
  mutating func clearHistory() {self._history = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// 1   - 99  = From Router
  /// 101 - 199 = From Client
  enum RequestResponse: SwiftProtobuf.Enum {
    typealias RawValue = Int

    ///
    /// Unset/unused
    case unset // = 0
    case routerError // = 1
    case routerHeartbeat // = 2

    ///
    /// Router has requested the client respond. This can work as a
    /// "are you there" message.
    case routerPing // = 3

    ///
    /// The response to a "Ping"
    case routerPong // = 4

    ///
    /// Router is currently busy. Please try again later.
    case routerBusy // = 5
    case clientError // = 101

    ///
    /// Client has requested a replay from the router.
    case clientHistory // = 102

    ///
    /// Client has requested stats from the router.
    case clientStats // = 103

    ///
    /// Client has requested the router respond. This can work as a
    /// "are you there" message.
    case clientPing // = 104

    ///
    /// The response to a "Ping"
    case clientPong // = 105
    case max // = 255
    case UNRECOGNIZED(Int)

    init() {
      self = .unset
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 1: self = .routerError
      case 2: self = .routerHeartbeat
      case 3: self = .routerPing
      case 4: self = .routerPong
      case 5: self = .routerBusy
      case 101: self = .clientError
      case 102: self = .clientHistory
      case 103: self = .clientStats
      case 104: self = .clientPing
      case 105: self = .clientPong
      case 255: self = .max
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unset: return 0
      case .routerError: return 1
      case .routerHeartbeat: return 2
      case .routerPing: return 3
      case .routerPong: return 4
      case .routerBusy: return 5
      case .clientError: return 101
      case .clientHistory: return 102
      case .clientStats: return 103
      case .clientPing: return 104
      case .clientPong: return 105
      case .max: return 255
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct Statistics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Number of messages we have ever seen
    var messagesTotal: UInt32 = 0

    ///
    /// Number of messages we have currently saved our history.
    var messagesSaved: UInt32 = 0

    ///
    /// Maximum number of messages we will save
    var messagesMax: UInt32 = 0

    ///
    /// Router uptime in seconds
    var upTime: UInt32 = 0

    ///
    /// Number of times any client sent a request to the S&F.
    var requests: UInt32 = 0

    ///
    /// Number of times the history was requested.
    var requestsHistory: UInt32 = 0

    ///
    /// Is the heartbeat enabled on the server?
    var heartbeat: Bool = false

    ///
    /// Is the heartbeat enabled on the server?
    var returnMax: UInt32 = 0

    ///
    /// Is the heartbeat enabled on the server?
    var returnWindow: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct History {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// Number of that will be sent to the client
    var historyMessages: UInt32 = 0

    ///
    /// The window of messages that was used to filter the history client requested
    var window: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _stats: StoreAndForwardMessage.Statistics?
  fileprivate var _history: StoreAndForwardMessage.History?
}

#if swift(>=4.2)

extension StoreAndForwardMessage.RequestResponse: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [StoreAndForwardMessage.RequestResponse] = [
    .unset,
    .routerError,
    .routerHeartbeat,
    .routerPing,
    .routerPong,
    .routerBusy,
    .clientError,
    .clientHistory,
    .clientStats,
    .clientPing,
    .clientPong,
    .max
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension StoreAndForwardMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoreAndForwardMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rr"),
    2: .same(proto: "stats"),
    3: .same(proto: "history")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.rr) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._history) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.rr != .unset {
      try visitor.visitSingularEnumField(value: self.rr, fieldNumber: 1)
    }
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._history {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoreAndForwardMessage, rhs: StoreAndForwardMessage) -> Bool {
    if lhs.rr != rhs.rr {return false}
    if lhs._stats != rhs._stats {return false}
    if lhs._history != rhs._history {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoreAndForwardMessage.RequestResponse: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "ROUTER_ERROR"),
    2: .same(proto: "ROUTER_HEARTBEAT"),
    3: .same(proto: "ROUTER_PING"),
    4: .same(proto: "ROUTER_PONG"),
    5: .same(proto: "ROUTER_BUSY"),
    101: .same(proto: "CLIENT_ERROR"),
    102: .same(proto: "CLIENT_HISTORY"),
    103: .same(proto: "CLIENT_STATS"),
    104: .same(proto: "CLIENT_PING"),
    105: .same(proto: "CLIENT_PONG"),
    255: .same(proto: "MAX")
  ]
}

extension StoreAndForwardMessage.Statistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StoreAndForwardMessage.protoMessageName + ".Statistics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MessagesTotal"),
    2: .same(proto: "MessagesSaved"),
    3: .same(proto: "MessagesMax"),
    4: .same(proto: "UpTime"),
    5: .same(proto: "Requests"),
    6: .same(proto: "RequestsHistory"),
    7: .same(proto: "Heartbeat"),
    8: .same(proto: "ReturnMax"),
    9: .same(proto: "ReturnWindow")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.messagesTotal) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.messagesSaved) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.messagesMax) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.upTime) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.requests) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.requestsHistory) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.heartbeat) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.returnMax) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.returnWindow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messagesTotal != 0 {
      try visitor.visitSingularUInt32Field(value: self.messagesTotal, fieldNumber: 1)
    }
    if self.messagesSaved != 0 {
      try visitor.visitSingularUInt32Field(value: self.messagesSaved, fieldNumber: 2)
    }
    if self.messagesMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.messagesMax, fieldNumber: 3)
    }
    if self.upTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.upTime, fieldNumber: 4)
    }
    if self.requests != 0 {
      try visitor.visitSingularUInt32Field(value: self.requests, fieldNumber: 5)
    }
    if self.requestsHistory != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestsHistory, fieldNumber: 6)
    }
    if self.heartbeat != false {
      try visitor.visitSingularBoolField(value: self.heartbeat, fieldNumber: 7)
    }
    if self.returnMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.returnMax, fieldNumber: 8)
    }
    if self.returnWindow != 0 {
      try visitor.visitSingularUInt32Field(value: self.returnWindow, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoreAndForwardMessage.Statistics, rhs: StoreAndForwardMessage.Statistics) -> Bool {
    if lhs.messagesTotal != rhs.messagesTotal {return false}
    if lhs.messagesSaved != rhs.messagesSaved {return false}
    if lhs.messagesMax != rhs.messagesMax {return false}
    if lhs.upTime != rhs.upTime {return false}
    if lhs.requests != rhs.requests {return false}
    if lhs.requestsHistory != rhs.requestsHistory {return false}
    if lhs.heartbeat != rhs.heartbeat {return false}
    if lhs.returnMax != rhs.returnMax {return false}
    if lhs.returnWindow != rhs.returnWindow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoreAndForwardMessage.History: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StoreAndForwardMessage.protoMessageName + ".History"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HistoryMessages"),
    2: .same(proto: "Window")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.historyMessages) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.window) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.historyMessages != 0 {
      try visitor.visitSingularUInt32Field(value: self.historyMessages, fieldNumber: 1)
    }
    if self.window != 0 {
      try visitor.visitSingularUInt32Field(value: self.window, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoreAndForwardMessage.History, rhs: StoreAndForwardMessage.History) -> Bool {
    if lhs.historyMessages != rhs.historyMessages {return false}
    if lhs.window != rhs.window {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
