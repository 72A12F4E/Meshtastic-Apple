// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  /// TODO: REPLACE
  var payloadVariant: Config.OneOf_PayloadVariant? = nil

  ///
  /// TODO: REPLACE
  var deviceConfig: Config.DeviceConfig {
    get {
      if case .deviceConfig(let v)? = payloadVariant {return v}
      return Config.DeviceConfig()
    }
    set {payloadVariant = .deviceConfig(newValue)}
  }

  ///
  /// TODO: REPLACE
  var gpsConfig: Config.GpsConfig {
    get {
      if case .gpsConfig(let v)? = payloadVariant {return v}
      return Config.GpsConfig()
    }
    set {payloadVariant = .gpsConfig(newValue)}
  }

  ///
  /// TODO: REPLACE
  var powerConfig: Config.PowerConfig {
    get {
      if case .powerConfig(let v)? = payloadVariant {return v}
      return Config.PowerConfig()
    }
    set {payloadVariant = .powerConfig(newValue)}
  }

  ///
  /// TODO: REPLACE
  var wifiConfig: Config.WiFiConfig {
    get {
      if case .wifiConfig(let v)? = payloadVariant {return v}
      return Config.WiFiConfig()
    }
    set {payloadVariant = .wifiConfig(newValue)}
  }

  ///
  /// TODO: REPLACE
  var displayConfig: Config.DisplayConfig {
    get {
      if case .displayConfig(let v)? = payloadVariant {return v}
      return Config.DisplayConfig()
    }
    set {payloadVariant = .displayConfig(newValue)}
  }

  ///
  /// TODO: REPLACE
  var loraConfig: Config.LoRaConfig {
    get {
      if case .loraConfig(let v)? = payloadVariant {return v}
      return Config.LoRaConfig()
    }
    set {payloadVariant = .loraConfig(newValue)}
  }

  ///
  /// TODO: REPLACE
  var moduleConfig: Config.ModuleConfig {
    get {
      if case .moduleConfig(let v)? = payloadVariant {return v}
      return Config.ModuleConfig()
    }
    set {payloadVariant = .moduleConfig(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///
  /// TODO: REPLACE
  enum OneOf_PayloadVariant: Equatable {
    ///
    /// TODO: REPLACE
    case deviceConfig(Config.DeviceConfig)
    ///
    /// TODO: REPLACE
    case gpsConfig(Config.GpsConfig)
    ///
    /// TODO: REPLACE
    case powerConfig(Config.PowerConfig)
    ///
    /// TODO: REPLACE
    case wifiConfig(Config.WiFiConfig)
    ///
    /// TODO: REPLACE
    case displayConfig(Config.DisplayConfig)
    ///
    /// TODO: REPLACE
    case loraConfig(Config.LoRaConfig)
    ///
    /// TODO: REPLACE
    case moduleConfig(Config.ModuleConfig)

  #if !swift(>=4.1)
    static func ==(lhs: Config.OneOf_PayloadVariant, rhs: Config.OneOf_PayloadVariant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.deviceConfig, .deviceConfig): return {
        guard case .deviceConfig(let l) = lhs, case .deviceConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gpsConfig, .gpsConfig): return {
        guard case .gpsConfig(let l) = lhs, case .gpsConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.powerConfig, .powerConfig): return {
        guard case .powerConfig(let l) = lhs, case .powerConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wifiConfig, .wifiConfig): return {
        guard case .wifiConfig(let l) = lhs, case .wifiConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.displayConfig, .displayConfig): return {
        guard case .displayConfig(let l) = lhs, case .displayConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loraConfig, .loraConfig): return {
        guard case .loraConfig(let l) = lhs, case .loraConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.moduleConfig, .moduleConfig): return {
        guard case .moduleConfig(let l) = lhs, case .moduleConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  ///
  /// TODO: REPLACE
  struct DeviceConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// TODO: REPLACE
  struct GpsConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// TODO: REPLACE
  struct PowerConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// TODO: REPLACE
  struct WiFiConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// If set, this node will try to join the specified wifi network and
    /// acquire an address via DHCP
    var wifiSsid: String = String()

    ///
    /// If set, will be use to authenticate to the named wifi
    var wifiPassword: String = String()

    ///
    /// If set, the node will operate as an AP (and DHCP server), otherwise it
    /// will be a station
    var wifiApMode: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// TODO: REPLACE
  struct DisplayConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// TODO: REPLACE
  struct LoRaConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  ///
  /// TODO: REPLACE
  struct ModuleConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    /// TODO: REPLACE
    var payloadVariant: Config.ModuleConfig.OneOf_PayloadVariant? = nil

    ///
    /// TODO: REPLACE
    var mqttConfig: Config.ModuleConfig.MQTTConfig {
      get {
        if case .mqttConfig(let v)? = payloadVariant {return v}
        return Config.ModuleConfig.MQTTConfig()
      }
      set {payloadVariant = .mqttConfig(newValue)}
    }

    ///
    /// TODO: REPLACE
    var serialConfig: Config.ModuleConfig.SerialConfig {
      get {
        if case .serialConfig(let v)? = payloadVariant {return v}
        return Config.ModuleConfig.SerialConfig()
      }
      set {payloadVariant = .serialConfig(newValue)}
    }

    ///
    /// TODO: REPLACE
    var externalNotificationConfig: Config.ModuleConfig.ExternalNotificationConfig {
      get {
        if case .externalNotificationConfig(let v)? = payloadVariant {return v}
        return Config.ModuleConfig.ExternalNotificationConfig()
      }
      set {payloadVariant = .externalNotificationConfig(newValue)}
    }

    ///
    /// TODO: REPLACE
    var storeForwardConfig: Config.ModuleConfig.StoreForwardConfig {
      get {
        if case .storeForwardConfig(let v)? = payloadVariant {return v}
        return Config.ModuleConfig.StoreForwardConfig()
      }
      set {payloadVariant = .storeForwardConfig(newValue)}
    }

    ///
    /// TODO: REPLACE
    var rangeTestConfig: Config.ModuleConfig.RangeTestConfig {
      get {
        if case .rangeTestConfig(let v)? = payloadVariant {return v}
        return Config.ModuleConfig.RangeTestConfig()
      }
      set {payloadVariant = .rangeTestConfig(newValue)}
    }

    ///
    /// TODO: REPLACE
    var telemetryConfig: Config.ModuleConfig.TelemetryConfig {
      get {
        if case .telemetryConfig(let v)? = payloadVariant {return v}
        return Config.ModuleConfig.TelemetryConfig()
      }
      set {payloadVariant = .telemetryConfig(newValue)}
    }

    ///
    /// TODO: REPLACE
    var cannedMessageConfig: Config.ModuleConfig.CannedMessageConfig {
      get {
        if case .cannedMessageConfig(let v)? = payloadVariant {return v}
        return Config.ModuleConfig.CannedMessageConfig()
      }
      set {payloadVariant = .cannedMessageConfig(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    ///
    /// TODO: REPLACE
    enum OneOf_PayloadVariant: Equatable {
      ///
      /// TODO: REPLACE
      case mqttConfig(Config.ModuleConfig.MQTTConfig)
      ///
      /// TODO: REPLACE
      case serialConfig(Config.ModuleConfig.SerialConfig)
      ///
      /// TODO: REPLACE
      case externalNotificationConfig(Config.ModuleConfig.ExternalNotificationConfig)
      ///
      /// TODO: REPLACE
      case storeForwardConfig(Config.ModuleConfig.StoreForwardConfig)
      ///
      /// TODO: REPLACE
      case rangeTestConfig(Config.ModuleConfig.RangeTestConfig)
      ///
      /// TODO: REPLACE
      case telemetryConfig(Config.ModuleConfig.TelemetryConfig)
      ///
      /// TODO: REPLACE
      case cannedMessageConfig(Config.ModuleConfig.CannedMessageConfig)

    #if !swift(>=4.1)
      static func ==(lhs: Config.ModuleConfig.OneOf_PayloadVariant, rhs: Config.ModuleConfig.OneOf_PayloadVariant) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.mqttConfig, .mqttConfig): return {
          guard case .mqttConfig(let l) = lhs, case .mqttConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.serialConfig, .serialConfig): return {
          guard case .serialConfig(let l) = lhs, case .serialConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.externalNotificationConfig, .externalNotificationConfig): return {
          guard case .externalNotificationConfig(let l) = lhs, case .externalNotificationConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.storeForwardConfig, .storeForwardConfig): return {
          guard case .storeForwardConfig(let l) = lhs, case .storeForwardConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.rangeTestConfig, .rangeTestConfig): return {
          guard case .rangeTestConfig(let l) = lhs, case .rangeTestConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.telemetryConfig, .telemetryConfig): return {
          guard case .telemetryConfig(let l) = lhs, case .telemetryConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.cannedMessageConfig, .cannedMessageConfig): return {
          guard case .cannedMessageConfig(let l) = lhs, case .cannedMessageConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    ///
    /// TODO: REPLACE
    struct MQTTConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    ///
    /// TODO: REPLACE
    struct SerialConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    ///
    /// TODO: REPLACE
    struct ExternalNotificationConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    ///
    /// TODO: REPLACE
    struct StoreForwardConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    ///
    /// TODO: REPLACE
    struct RangeTestConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    ///
    /// Configuration for both device and environment metrics
    struct TelemetryConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      ///
      /// Interval in seconds of how often we should try to send our
      /// device measurements to the mesh
      var deviceUpdateInterval: UInt32 = 0

      ///
      /// Interval in seconds of how often we should try to send our
      /// environment measurements to the mesh
      var environmentUpdateInterval: UInt32 = 0

      ///
      /// Preferences for the Telemetry Module (Environment)
      /// Enable/Disable the telemetry measurement module measurement collection
      var environmentMeasurementEnabled: Bool = false

      ///
      /// Enable/Disable the telemetry measurement module on-device display
      var environmentScreenEnabled: Bool = false

      ///
      /// Sometimes sensor reads can fail.
      /// If this happens, we will retry a configurable number of attempts,
      /// each attempt will be delayed by the minimum required refresh rate for that sensor
      var environmentReadErrorCountThreshold: UInt32 = 0

      ///
      /// Sometimes we can end up with more than read_error_count_threshold failures.
      /// In this case, we will stop trying to read from the sensor for a while.
      /// Wait this long until trying to read from the sensor again
      var environmentRecoveryInterval: UInt32 = 0

      ///
      /// We'll always read the sensor in Celsius, but sometimes we might want to
      /// display the results in Fahrenheit as a "user preference".
      var environmentDisplayFahrenheit: Bool = false

      ///
      /// Specify the sensor type
      var environmentSensorType: TelemetrySensorType = .notSet

      ///
      /// Specify the peferred GPIO Pin for sensor readings
      var environmentSensorPin: UInt32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    ///
    /// TODO: REPLACE
    struct CannedMessageConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Config: @unchecked Sendable {}
extension Config.OneOf_PayloadVariant: @unchecked Sendable {}
extension Config.DeviceConfig: @unchecked Sendable {}
extension Config.GpsConfig: @unchecked Sendable {}
extension Config.PowerConfig: @unchecked Sendable {}
extension Config.WiFiConfig: @unchecked Sendable {}
extension Config.DisplayConfig: @unchecked Sendable {}
extension Config.LoRaConfig: @unchecked Sendable {}
extension Config.ModuleConfig: @unchecked Sendable {}
extension Config.ModuleConfig.OneOf_PayloadVariant: @unchecked Sendable {}
extension Config.ModuleConfig.MQTTConfig: @unchecked Sendable {}
extension Config.ModuleConfig.SerialConfig: @unchecked Sendable {}
extension Config.ModuleConfig.ExternalNotificationConfig: @unchecked Sendable {}
extension Config.ModuleConfig.StoreForwardConfig: @unchecked Sendable {}
extension Config.ModuleConfig.RangeTestConfig: @unchecked Sendable {}
extension Config.ModuleConfig.TelemetryConfig: @unchecked Sendable {}
extension Config.ModuleConfig.CannedMessageConfig: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Config"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_config"),
    2: .standard(proto: "gps_config"),
    3: .standard(proto: "power_config"),
    4: .standard(proto: "wifi_config"),
    5: .standard(proto: "display_config"),
    6: .standard(proto: "lora_config"),
    7: .standard(proto: "module_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Config.DeviceConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .deviceConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .deviceConfig(v)
        }
      }()
      case 2: try {
        var v: Config.GpsConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .gpsConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .gpsConfig(v)
        }
      }()
      case 3: try {
        var v: Config.PowerConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .powerConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .powerConfig(v)
        }
      }()
      case 4: try {
        var v: Config.WiFiConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .wifiConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .wifiConfig(v)
        }
      }()
      case 5: try {
        var v: Config.DisplayConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .displayConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .displayConfig(v)
        }
      }()
      case 6: try {
        var v: Config.LoRaConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .loraConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .loraConfig(v)
        }
      }()
      case 7: try {
        var v: Config.ModuleConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .moduleConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .moduleConfig(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payloadVariant {
    case .deviceConfig?: try {
      guard case .deviceConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gpsConfig?: try {
      guard case .gpsConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .powerConfig?: try {
      guard case .powerConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .wifiConfig?: try {
      guard case .wifiConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .displayConfig?: try {
      guard case .displayConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .loraConfig?: try {
      guard case .loraConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .moduleConfig?: try {
      guard case .moduleConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config, rhs: Config) -> Bool {
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.DeviceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".DeviceConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.DeviceConfig, rhs: Config.DeviceConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.GpsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".GpsConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.GpsConfig, rhs: Config.GpsConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.PowerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".PowerConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.PowerConfig, rhs: Config.PowerConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.WiFiConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".WiFiConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wifi_ssid"),
    2: .standard(proto: "wifi_password"),
    3: .standard(proto: "wifi_ap_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.wifiSsid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.wifiPassword) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.wifiApMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.wifiSsid.isEmpty {
      try visitor.visitSingularStringField(value: self.wifiSsid, fieldNumber: 1)
    }
    if !self.wifiPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.wifiPassword, fieldNumber: 2)
    }
    if self.wifiApMode != false {
      try visitor.visitSingularBoolField(value: self.wifiApMode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.WiFiConfig, rhs: Config.WiFiConfig) -> Bool {
    if lhs.wifiSsid != rhs.wifiSsid {return false}
    if lhs.wifiPassword != rhs.wifiPassword {return false}
    if lhs.wifiApMode != rhs.wifiApMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.DisplayConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".DisplayConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.DisplayConfig, rhs: Config.DisplayConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.LoRaConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".LoRaConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.LoRaConfig, rhs: Config.LoRaConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.ModuleConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.protoMessageName + ".ModuleConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mqtt_config"),
    2: .standard(proto: "serial_config"),
    3: .standard(proto: "external_notification_config"),
    4: .standard(proto: "store_forward_config"),
    5: .standard(proto: "range_test_config"),
    6: .standard(proto: "telemetry_config"),
    7: .standard(proto: "canned_message_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Config.ModuleConfig.MQTTConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .mqttConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .mqttConfig(v)
        }
      }()
      case 2: try {
        var v: Config.ModuleConfig.SerialConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .serialConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .serialConfig(v)
        }
      }()
      case 3: try {
        var v: Config.ModuleConfig.ExternalNotificationConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .externalNotificationConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .externalNotificationConfig(v)
        }
      }()
      case 4: try {
        var v: Config.ModuleConfig.StoreForwardConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .storeForwardConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .storeForwardConfig(v)
        }
      }()
      case 5: try {
        var v: Config.ModuleConfig.RangeTestConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .rangeTestConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .rangeTestConfig(v)
        }
      }()
      case 6: try {
        var v: Config.ModuleConfig.TelemetryConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .telemetryConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .telemetryConfig(v)
        }
      }()
      case 7: try {
        var v: Config.ModuleConfig.CannedMessageConfig?
        var hadOneofValue = false
        if let current = self.payloadVariant {
          hadOneofValue = true
          if case .cannedMessageConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payloadVariant = .cannedMessageConfig(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payloadVariant {
    case .mqttConfig?: try {
      guard case .mqttConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .serialConfig?: try {
      guard case .serialConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .externalNotificationConfig?: try {
      guard case .externalNotificationConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .storeForwardConfig?: try {
      guard case .storeForwardConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rangeTestConfig?: try {
      guard case .rangeTestConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .telemetryConfig?: try {
      guard case .telemetryConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .cannedMessageConfig?: try {
      guard case .cannedMessageConfig(let v)? = self.payloadVariant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.ModuleConfig, rhs: Config.ModuleConfig) -> Bool {
    if lhs.payloadVariant != rhs.payloadVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.ModuleConfig.MQTTConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.ModuleConfig.protoMessageName + ".MQTTConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.ModuleConfig.MQTTConfig, rhs: Config.ModuleConfig.MQTTConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.ModuleConfig.SerialConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.ModuleConfig.protoMessageName + ".SerialConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.ModuleConfig.SerialConfig, rhs: Config.ModuleConfig.SerialConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.ModuleConfig.ExternalNotificationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.ModuleConfig.protoMessageName + ".ExternalNotificationConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.ModuleConfig.ExternalNotificationConfig, rhs: Config.ModuleConfig.ExternalNotificationConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.ModuleConfig.StoreForwardConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.ModuleConfig.protoMessageName + ".StoreForwardConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.ModuleConfig.StoreForwardConfig, rhs: Config.ModuleConfig.StoreForwardConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.ModuleConfig.RangeTestConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.ModuleConfig.protoMessageName + ".RangeTestConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.ModuleConfig.RangeTestConfig, rhs: Config.ModuleConfig.RangeTestConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.ModuleConfig.TelemetryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.ModuleConfig.protoMessageName + ".TelemetryConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_update_interval"),
    2: .standard(proto: "environment_update_interval"),
    3: .standard(proto: "environment_measurement_enabled"),
    4: .standard(proto: "environment_screen_enabled"),
    5: .standard(proto: "environment_read_error_count_threshold"),
    6: .standard(proto: "environment_recovery_interval"),
    7: .standard(proto: "environment_display_fahrenheit"),
    8: .standard(proto: "environment_sensor_type"),
    9: .standard(proto: "environment_sensor_pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.deviceUpdateInterval) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.environmentUpdateInterval) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.environmentMeasurementEnabled) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.environmentScreenEnabled) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.environmentReadErrorCountThreshold) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.environmentRecoveryInterval) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.environmentDisplayFahrenheit) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.environmentSensorType) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.environmentSensorPin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.deviceUpdateInterval, fieldNumber: 1)
    }
    if self.environmentUpdateInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.environmentUpdateInterval, fieldNumber: 2)
    }
    if self.environmentMeasurementEnabled != false {
      try visitor.visitSingularBoolField(value: self.environmentMeasurementEnabled, fieldNumber: 3)
    }
    if self.environmentScreenEnabled != false {
      try visitor.visitSingularBoolField(value: self.environmentScreenEnabled, fieldNumber: 4)
    }
    if self.environmentReadErrorCountThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.environmentReadErrorCountThreshold, fieldNumber: 5)
    }
    if self.environmentRecoveryInterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.environmentRecoveryInterval, fieldNumber: 6)
    }
    if self.environmentDisplayFahrenheit != false {
      try visitor.visitSingularBoolField(value: self.environmentDisplayFahrenheit, fieldNumber: 7)
    }
    if self.environmentSensorType != .notSet {
      try visitor.visitSingularEnumField(value: self.environmentSensorType, fieldNumber: 8)
    }
    if self.environmentSensorPin != 0 {
      try visitor.visitSingularUInt32Field(value: self.environmentSensorPin, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.ModuleConfig.TelemetryConfig, rhs: Config.ModuleConfig.TelemetryConfig) -> Bool {
    if lhs.deviceUpdateInterval != rhs.deviceUpdateInterval {return false}
    if lhs.environmentUpdateInterval != rhs.environmentUpdateInterval {return false}
    if lhs.environmentMeasurementEnabled != rhs.environmentMeasurementEnabled {return false}
    if lhs.environmentScreenEnabled != rhs.environmentScreenEnabled {return false}
    if lhs.environmentReadErrorCountThreshold != rhs.environmentReadErrorCountThreshold {return false}
    if lhs.environmentRecoveryInterval != rhs.environmentRecoveryInterval {return false}
    if lhs.environmentDisplayFahrenheit != rhs.environmentDisplayFahrenheit {return false}
    if lhs.environmentSensorType != rhs.environmentSensorType {return false}
    if lhs.environmentSensorPin != rhs.environmentSensorPin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Config.ModuleConfig.CannedMessageConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Config.ModuleConfig.protoMessageName + ".CannedMessageConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Config.ModuleConfig.CannedMessageConfig, rhs: Config.ModuleConfig.CannedMessageConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
